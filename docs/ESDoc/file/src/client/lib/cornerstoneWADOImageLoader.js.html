<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">src/client/lib/cornerstoneWADOImageLoader.js | prototype-breast-screening</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="MIMBCD-UI Prototype Breast Screening"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="prototype-breast-screening"><meta property="twitter:description" content="MIMBCD-UI Prototype Breast Screening"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/MIMBCD-UI/prototype-breast-screening"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#client-lib">client/lib</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-PromiseCapability">PromiseCapability</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/client/lib/cornerstoneWADOImageLoader.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/*! cornerstone-wado-image-loader - v0.7.0 - 2015-09-06 | (c) 2014 Chris Hafey | https://github.com/chafey/cornerstoneWADOImageLoader */
//
// This is a cornerstone image loader for WADO-URI requests.  It has limited support for compressed
// transfer syntaxes, check here to see what is currently supported:
//
// https://github.com/chafey/cornerstoneWADOImageLoader/blob/master/docs/TransferSyntaxes.md
//
// It will support implicit little endian transfer syntaxes but explicit little endian is strongly preferred
// to avoid any parsing issues related to SQ elements.  To request that the WADO object be returned as explicit little endian, append
// the following on your WADO url: &amp;transferSyntax=1.2.840.10008.1.2.1
//

if(typeof cornerstone === &apos;undefined&apos;){
  cornerstone = {};
}
if(typeof cornerstoneWADOImageLoader === &apos;undefined&apos;){
  cornerstoneWADOImageLoader = {
    internal: {
      options : {
        // callback allowing customization of the xhr (e.g. adding custom auth headers, cors, etc)
        beforeSend: function (xhr) {
        }
      },
      multiFrameCacheHack : {}
    }
  };
}


(function (cornerstoneWADOImageLoader) {

  &quot;use strict&quot;;

  function convertRGB(dataSet, decodedImageFrame, rgbaBuffer) {
    var planarConfiguration = dataSet.uint16(&apos;x00280006&apos;);
    if(planarConfiguration === 0) {
      cornerstoneWADOImageLoader.convertRGBColorByPixel(decodedImageFrame, rgbaBuffer);
    } else {
      cornerstoneWADOImageLoader.convertRGBColorByPlane(decodedImageFrame, rgbaBuffer);
    }
  }

  function convertColorSpace(canvas, dataSet, imageFrame) {
    // extract the fields we need
    var height = dataSet.uint16(&apos;x00280010&apos;);
    var width = dataSet.uint16(&apos;x00280011&apos;);
    var photometricInterpretation = dataSet.string(&apos;x00280004&apos;);

    // setup the canvas context
    canvas.height = height;
    canvas.width = width;
    var context = canvas.getContext(&apos;2d&apos;);
    var imageData = context.createImageData(width, height);


    // convert based on the photometric interpretation
    var deferred = $.Deferred();
    try {
      if (photometricInterpretation === &quot;RGB&quot; )
      {
        convertRGB(dataSet, imageFrame, imageData.data);
      }
      else if (photometricInterpretation === &quot;YBR_RCT&quot;)
      {
        convertRGB(dataSet, imageFrame, imageData.data);
      }
      else if (photometricInterpretation === &quot;YBR_ICT&quot;)
      {
        convertRGB(dataSet, imageFrame, imageData.data);
      }
      else if( photometricInterpretation === &quot;PALETTE COLOR&quot; )
      {
        cornerstoneWADOImageLoader.convertPALETTECOLOR(imageFrame, imageData.data, dataSet );
      }
      else if( photometricInterpretation === &quot;YBR_FULL_422&quot; )
      {
        cornerstoneWADOImageLoader.convertYBRFull(imageFrame, imageData.data);
      }
      else if(photometricInterpretation === &quot;YBR_FULL&quot; )
      {
        cornerstoneWADOImageLoader.convertYBRFull(imageFrame, imageData.data);
      }
      else
      {
        throw &quot;no color space conversion for photometric interpretation &quot; + photometricInterpretation;
      }
      deferred.resolve(imageData);
      return deferred;
    } catch (error) {
      deferred.reject(error);
      return deferred;
    }
  }

  // module exports
  cornerstoneWADOImageLoader.convertColorSpace = convertColorSpace;

}(cornerstoneWADOImageLoader));
(function (cornerstoneWADOImageLoader) {

  &quot;use strict&quot;;

  function convertPALETTECOLOR( imageFrame, rgbaBuffer, dataSet ) {
    var len=dataSet.int16(&apos;x00281101&apos;,0);
    var start=dataSet.int16(&apos;x00281101&apos;,1);
    var bits=dataSet.int16(&apos;x00281101&apos;,2);
    var shift = (bits===8 ? 0 : 8 );

    var buffer = dataSet.byteArray.buffer;
    var rData=new Uint16Array( buffer, dataSet.elements.x00281201.dataOffset, len );
    var gData=new Uint16Array( buffer, dataSet.elements.x00281202.dataOffset, len );
    var bData=new Uint16Array( buffer, dataSet.elements.x00281203.dataOffset, len );

    var numPixels = dataSet.uint16(&apos;x00280010&apos;) * dataSet.uint16(&apos;x00280011&apos;);
    var palIndex=0;
    var rgbaIndex=0;

    for( var i=0 ; i &lt; numPixels ; ++i ) {
      var value=imageFrame[palIndex++];
      if( value &lt; start )
        value=0;
      else if( value &gt; start + len -1 )
        value=len-1;
      else
        value=value-start;

      rgbaBuffer[ rgbaIndex++ ] = rData[value] &gt;&gt; shift;
      rgbaBuffer[ rgbaIndex++ ] = gData[value] &gt;&gt; shift;
      rgbaBuffer[ rgbaIndex++ ] = bData[value] &gt;&gt; shift;
      rgbaBuffer[ rgbaIndex++ ] = 255;
    }

  }

  // module exports
  cornerstoneWADOImageLoader.convertPALETTECOLOR = convertPALETTECOLOR;

}(cornerstoneWADOImageLoader));
/**
 */
(function (cornerstoneWADOImageLoader) {

    &quot;use strict&quot;;

    function convertRGBColorByPixel(imageFrame, rgbaBuffer) {
        if(imageFrame === undefined) {
            throw &quot;decodeRGB: rgbBuffer must not be undefined&quot;;
        }
        if(imageFrame.length % 3 !== 0) {
            throw &quot;decodeRGB: rgbBuffer length must be divisible by 3&quot;;
        }

        var numPixels = imageFrame.length / 3;
        var rgbIndex = 0;
        var rgbaIndex = 0;
        for(var i= 0; i &lt; numPixels; i++) {
            rgbaBuffer[rgbaIndex++] = imageFrame[rgbIndex++]; // red
            rgbaBuffer[rgbaIndex++] = imageFrame[rgbIndex++]; // green
            rgbaBuffer[rgbaIndex++] = imageFrame[rgbIndex++]; // blue
            rgbaBuffer[rgbaIndex++] = 255; //alpha
        }
    }

    // module exports
    cornerstoneWADOImageLoader.convertRGBColorByPixel = convertRGBColorByPixel;
}(cornerstoneWADOImageLoader));
/**
 */
(function (cornerstoneWADOImageLoader) {

  &quot;use strict&quot;;

  function convertRGBColorByPlane(imageFrame, rgbaBuffer) {
    if(imageFrame === undefined) {
      throw &quot;decodeRGB: rgbBuffer must not be undefined&quot;;
    }
    if(imageFrame.length % 3 !== 0) {
      throw &quot;decodeRGB: rgbBuffer length must be divisible by 3&quot;;
    }

    var numPixels = imageFrame.length / 3;
    var rgbaIndex = 0;
    for(var i= 0; i &lt; numPixels; i++) {
      var rIndex = 0;
      var gIndex = numPixels;
      var bIndex = numPixels*2;
      for(var i= 0; i &lt; numPixels; i++) {
        rgbaBuffer[rgbaIndex++] = imageFrame[rIndex++]; // red
        rgbaBuffer[rgbaIndex++] = imageFrame[gIndex++]; // green
        rgbaBuffer[rgbaIndex++] = imageFrame[bIndex++]; // blue
        rgbaBuffer[rgbaIndex++] = 255; //alpha
      }
    }
  }

  // module exports
  cornerstoneWADOImageLoader.convertRGBColorByPlane = convertRGBColorByPlane;
}(cornerstoneWADOImageLoader));
/**
 */
(function (cornerstoneWADOImageLoader) {

    &quot;use strict&quot;;

    function convertYBRFull(imageFrame, rgbaBuffer) {
        if(imageFrame === undefined) {
            throw &quot;decodeRGB: ybrBuffer must not be undefined&quot;;
        }
        if(imageFrame.length % 3 !== 0) {
            throw &quot;decodeRGB: ybrBuffer length must be divisble by 3&quot;;
        }

        var numPixels = imageFrame.length / 3;
        var ybrIndex = 0;
        var rgbaIndex = 0;
        for(var i= 0; i &lt; numPixels; i++) {
            var y = imageFrame[ybrIndex++];
            var cb = imageFrame[ybrIndex++];
            var cr = imageFrame[ybrIndex++];
            rgbaBuffer[rgbaIndex++] = y + 1.40200 * (cr - 128);// red
            rgbaBuffer[rgbaIndex++] = y - 0.34414 * (cb -128) - 0.71414 * (cr- 128); // green
            rgbaBuffer[rgbaIndex++] = y + 1.77200 * (cb - 128); // blue
            rgbaBuffer[rgbaIndex++] = 255; //alpha
        }
    }

    // module exports
    cornerstoneWADOImageLoader.convertYBRFull = convertYBRFull;
}(cornerstoneWADOImageLoader));
(function (cornerstoneWADOImageLoader) {

  &quot;use strict&quot;;

  function configure(options) {
    cornerstoneWADOImageLoader.internal.options = options;
  }

  // module exports
  cornerstoneWADOImageLoader.configure = configure;

}(cornerstoneWADOImageLoader));

(function ($, cornerstone, cornerstoneWADOImageLoader) {

    &quot;use strict&quot;;

    // Loads an image given an imageId
    // wado url example:
    // http://localhost:3333/wado?requestType=WADO&amp;studyUID=1.3.6.1.4.1.25403.166563008443.5076.20120418075541.1&amp;seriesUID=1.3.6.1.4.1.25403.166563008443.5076.20120418075541.2&amp;objectUID=1.3.6.1.4.1.25403.166563008443.5076.20120418075557.1&amp;contentType=application%2Fdicom&amp;transferSyntax=1.2.840.10008.1.2.1
    // NOTE: supposedly the instance will be returned in Explicit Little Endian transfer syntax if you don&apos;t
    // specify a transferSyntax but Osirix doesn&apos;t do this and seems to return it with the transfer syntax it is
    // stored as.
    function loadImage(imageId) {
        // create a deferred object

        // build a url by parsing out the url scheme and frame index from the imageId
        var firstColonIndex = imageId.indexOf(&apos;:&apos;);
        var url = imageId.substring(firstColonIndex + 1);
        var frameIndex = url.indexOf(&apos;frame=&apos;);
        var frame;
        if(frameIndex !== -1) {
            var frameStr = url.substr(frameIndex + 6);
            frame = parseInt(frameStr);
            url = url.substr(0, frameIndex-1);
        }

        // if multiframe and cached, use the cached data set to extract the frame
        if(frame !== undefined &amp;&amp;
          cornerstoneWADOImageLoader.internal.multiFrameCacheHack.hasOwnProperty(url))
        {
            var deferred = $.Deferred();
            var dataSet = cornerstoneWADOImageLoader.internal.multiFrameCacheHack[url];
            var imagePromise = cornerstoneWADOImageLoader.createImageObject(dataSet, imageId, frame);
            imagePromise.then(function(image) {
                deferred.resolve(image);
            }, function(error) {
                deferred.reject(error);
            });
            return deferred;
        }

        return cornerstoneWADOImageLoader.internal.xhrRequest(imageId, frame, url);
    }

    // registery dicomweb and wadouri image loader prefixes
    cornerstone.loadImage = loadImage;
    cornerstone.registerImageLoader(&apos;dicomweb&apos;, loadImage);
    cornerstone.registerImageLoader(&apos;wadouri&apos;, loadImage);

}($, cornerstone, cornerstoneWADOImageLoader));
(function (cornerstoneWADOImageLoader) {

  &quot;use strict&quot;;

  function createImageObject( dataSet, imageId, frame ) {
    if(frame === undefined) {
      frame = 0;
    }

    // make the image based on whether it is color or not
    var photometricInterpretation = dataSet.string(&apos;x00280004&apos;);
    var isColor = cornerstoneWADOImageLoader.isColorImage(photometricInterpretation);
    if(isColor === false) {
      return cornerstoneWADOImageLoader.makeGrayscaleImage(imageId, dataSet, frame);
    } else {
      return cornerstoneWADOImageLoader.makeColorImage(imageId, dataSet, frame);
    }
  }

  // module exports
  cornerstoneWADOImageLoader.createImageObject = createImageObject;

}(cornerstoneWADOImageLoader));
(function ($, cornerstone, cornerstoneWADOImageLoader) {

  &quot;use strict&quot;;
  function decodeJPEG2000(dataSet, frame)
  {
    var height = dataSet.uint16(&apos;x00280010&apos;);
    var width = dataSet.uint16(&apos;x00280011&apos;);
    var compressedPixelData = dicomParser.readEncapsulatedPixelData(dataSet, dataSet.elements.x7fe00010, frame);
    var jpxImage = new JpxImage();
    jpxImage.parse(compressedPixelData);

    var j2kWidth = jpxImage.width;
    var j2kHeight = jpxImage.height;
    if(j2kWidth !== width) {
      throw &apos;JPEG2000 decoder returned width of &apos; + j2kWidth + &apos;, when &apos; + width + &apos; is expected&apos;;
    }
    if(j2kHeight !== height) {
      throw &apos;JPEG2000 decoder returned width of &apos; + j2kHeight + &apos;, when &apos; + height + &apos; is expected&apos;;
    }
    var tileCount = jpxImage.tiles.length;
    if(tileCount !== 1) {
      throw &apos;JPEG2000 decoder returned a tileCount of &apos; + tileCount + &apos;, when 1 is expected&apos;;
    }
    var tileComponents = jpxImage.tiles[0];
    var pixelData = tileComponents.items;
    return pixelData;
  }

  cornerstoneWADOImageLoader.decodeJPEG2000 = decodeJPEG2000;
}($, cornerstone, cornerstoneWADOImageLoader));
(function ($, cornerstone, cornerstoneWADOImageLoader) {

  &quot;use strict&quot;;
  function decodeJPEGBaseline(dataSet, frame)
  {
    var pixelDataElement = dataSet.elements.x7fe00010;
    var height = dataSet.uint16(&apos;x00280010&apos;);
    var width = dataSet.uint16(&apos;x00280011&apos;);
    var bitsAllocated = dataSet.uint16(&apos;x00280100&apos;);
    var frameData = dicomParser.readEncapsulatedPixelData(dataSet, pixelDataElement, frame);
    var jpeg = new JpegImage();
    jpeg.parse( frameData );
    if(bitsAllocated === 8) {
      return jpeg.getData(width, height);
    }
    else if(bitsAllocated === 16) {
      return jpeg.getData16(width, height);
    }
  }

  cornerstoneWADOImageLoader.decodeJPEGBaseline = decodeJPEGBaseline;
}($, cornerstone, cornerstoneWADOImageLoader));
/**
 * Special decoder for 8 bit jpeg that leverages the browser&apos;s built in JPEG decoder for increased performance
 */
(function (cornerstoneWADOImageLoader) {

  &quot;use strict&quot;;

  function arrayBufferToString(buffer) {
    return binaryToString(String.fromCharCode.apply(null, Array.prototype.slice.apply(new Uint8Array(buffer))));
  }

  function binaryToString(binary) {
    var error;

    try {
      return decodeURIComponent(escape(binary));
    } catch (_error) {
      error = _error;
      if (error instanceof URIError) {
        return binary;
      } else {
        throw error;
      }
    }
  }

  function decodeJPEGBaseline8Bit(canvas, dataSet, frame) {
    var deferred = $.Deferred();

    var height = dataSet.uint16(&apos;x00280010&apos;);
    var width = dataSet.uint16(&apos;x00280011&apos;);
    // resize the canvas
    canvas.height = height;
    canvas.width = width;

    var encodedPixelData = dicomParser.readEncapsulatedPixelData(dataSet, dataSet.elements.x7fe00010, frame);

    var imgBlob = new Blob([encodedPixelData], {type: &quot;image/jpeg&quot;});

    var r = new FileReader();
    if(r.readAsBinaryString === undefined) {
      r.readAsArrayBuffer(imgBlob);
    }
    else {
      r.readAsBinaryString(imgBlob); // doesn&apos;t work on IE11
    }

    r.onload = function(){
      var img=new Image();
      img.onload = function() {
        var context = canvas.getContext(&apos;2d&apos;);
        context.drawImage(this, 0, 0);
        var imageData = context.getImageData(0, 0, width, height);
        deferred.resolve(imageData);
      };
      img.onerror = function(error) {
        deferred.reject(error);
      };
      if(r.readAsBinaryString === undefined) {
        img.src = &quot;data:image/jpeg;base64,&quot;+window.btoa(arrayBufferToString(r.result));
      }
      else {
        img.src = &quot;data:image/jpeg;base64,&quot;+window.btoa(r.result); // doesn&apos;t work on IE11
      }

    };
    return deferred;
  }

  function isJPEGBaseline8Bit(dataSet) {
    var transferSyntax = dataSet.string(&apos;x00020010&apos;);
    var bitsAllocated = dataSet.uint16(&apos;x00280100&apos;);

    if((bitsAllocated === 8) &amp;&amp;
      transferSyntax === &quot;1.2.840.10008.1.2.4.50&quot;)
    {
      return true;
    }

  }

  // module exports
  cornerstoneWADOImageLoader.decodeJPEGBaseline8Bit = decodeJPEGBaseline8Bit;
  cornerstoneWADOImageLoader.isJPEGBaseline8Bit = isJPEGBaseline8Bit;

}(cornerstoneWADOImageLoader));
&quot;use strict&quot;;
(function (cornerstoneWADOImageLoader) {

  function decodeJPEGLossless(dataSet, frame) {
    var pixelDataElement = dataSet.elements.x7fe00010;
    var bitsAllocated = dataSet.uint16(&apos;x00280100&apos;);
    var pixelRepresentation = dataSet.uint16(&apos;x00280103&apos;);
    var frameData = dicomParser.readEncapsulatedPixelData(dataSet, pixelDataElement, frame);
    var byteOutput = bitsAllocated &lt;= 8 ? 1 : 2;
    //console.time(&apos;jpeglossless&apos;);
    var decoder = new jpeg.lossless.Decoder();
    var decompressedData = decoder.decode(frameData.buffer, frameData.byteOffset, frameData.length, byteOutput);
    //console.timeEnd(&apos;jpeglossless&apos;);
    if (pixelRepresentation === 0) {
      if (byteOutput === 2) {
        return new Uint16Array(decompressedData.buffer);
      } else {
        // untested!
        return new Uint8Array(decompressedData.buffer);
      }
    } else {
      return new Int16Array(decompressedData.buffer);
    }
  }
  // module exports
  cornerstoneWADOImageLoader.decodeJPEGLossless = decodeJPEGLossless;

}(cornerstoneWADOImageLoader));
/**
 */
(function (cornerstoneWADOImageLoader) {

  function decodeRLE(dataSet, frame) {
    var height = dataSet.uint16(&apos;x00280010&apos;);
    var width = dataSet.uint16(&apos;x00280011&apos;);
    var samplesPerPixel = dataSet.uint16(&apos;x00280002&apos;);
    var pixelDataElement = dataSet.elements.x7fe00010;

    var frameData = dicomParser.readEncapsulatedPixelData(dataSet, pixelDataElement, frame);
    var pixelFormat = cornerstoneWADOImageLoader.getPixelFormat(dataSet);


    var frameSize = width*height;
    var buffer;
    if( pixelFormat===1 ) {
      buffer = new ArrayBuffer(frameSize*samplesPerPixel);
      decode8( frameData, buffer, frameSize, samplesPerPixel);
      return new Uint8Array(buffer);
    } else if( pixelFormat===2 ) {
      buffer = new ArrayBuffer(frameSize*samplesPerPixel*2);
      decode16( frameData, buffer, frameSize );
      return new Uint16Array(buffer);
    } else if( pixelFormat===3 ) {
      buffer = new ArrayBuffer(frameSize*samplesPerPixel*2);
      decode16( frameData, buffer, frameSize );
      return new Int16Array(buffer);
    }
  }

  function decode8( frameData, outFrame, frameSize, samplesSize ) {
    var header=new DataView(frameData.buffer, frameData.byteOffset);
    var data=new DataView( frameData.buffer, frameData.byteOffset );
    var out=new DataView( outFrame );

    var outIndex=0;
    var numSegments = header.getInt32(0,true);
    for( var s=0 ; s &lt; numSegments ; ++s ) {
      outIndex = s;

      var inIndex=header.getInt32( (s+1)*4,true);
      var maxIndex=header.getInt32( (s+2)*4,true);
      if( maxIndex===0 )
        maxIndex = frameData.length;

      var endOfSegment = frameSize * numSegments;

      while( inIndex &lt; maxIndex ) {
        var n=data.getInt8(inIndex++);
        if( n &gt;=0 &amp;&amp; n &lt;=127 ) {
          // copy n bytes
          for( var i=0 ; i &lt; n+1 &amp;&amp; outIndex &lt; endOfSegment; ++i ) {
            out.setInt8(outIndex, data.getInt8(inIndex++));
            outIndex+=samplesSize;
          }
        } else if( n&lt;= -1 &amp;&amp; n&gt;=-127 ) {
          var value=data.getInt8(inIndex++);
          // run of n bytes
          for( var j=0 ; j &lt; -n+1 &amp;&amp; outIndex &lt; endOfSegment; ++j ) {
            out.setInt8(outIndex, value );
            outIndex+=samplesSize;
          }
        } else if (n===-128)
          ; // do nothing
      }
    }
  }

  function decode16( frameData, outFrame, frameSize ) {
    var header=new DataView(frameData.buffer, frameData.byteOffset);
    var data=new DataView( frameData.buffer, frameData.byteOffset );
    var out=new DataView( outFrame );

    var numSegments = header.getInt32(0,true);
    for( var s=0 ; s &lt; numSegments ; ++s ) {
      var outIndex=0;
      var highByte=( s===0 ? 1 : 0);

      var inIndex=header.getInt32( (s+1)*4,true);
      var maxIndex=header.getInt32( (s+2)*4,true);
      if( maxIndex===0 )
        maxIndex = frameData.length;

      while( inIndex &lt; maxIndex ) {
        var n=data.getInt8(inIndex++);
        if( n &gt;=0 &amp;&amp; n &lt;=127 ) {
          for( var i=0 ; i &lt; n+1 &amp;&amp; outIndex &lt; frameSize ; ++i ) {
            out.setInt8( (outIndex*2)+highByte, data.getInt8(inIndex++) );
            outIndex++;
          }
        } else if( n&lt;= -1 &amp;&amp; n&gt;=-127 ) {
          var value=data.getInt8(inIndex++);
          for( var j=0 ; j &lt; -n+1 &amp;&amp; outIndex &lt; frameSize ; ++j ) {
            out.setInt8( (outIndex*2)+highByte, value );
            outIndex++;
          }
        } else if (n===-128)
          ; // do nothing
      }
    }
  }

  // module exports
  cornerstoneWADOImageLoader.decodeRLE = decodeRLE;

}(cornerstoneWADOImageLoader));
(function (cornerstoneWADOImageLoader) {

  &quot;use strict&quot;;

  function decodeTransferSyntax(dataSet, frame) {
    var transferSyntax = dataSet.string(&apos;x00020010&apos;);

    // Implicit VR Little Endian
    if( transferSyntax === &quot;1.2.840.10008.1.2&quot;) {
      return cornerstoneWADOImageLoader.extractUncompressedPixels(dataSet, frame);
    }
    // Explicit VR Little Endian
    else if( transferSyntax === &quot;1.2.840.10008.1.2.1&quot;) {
      return cornerstoneWADOImageLoader.extractUncompressedPixels(dataSet, frame);
    }
    // JPEG 2000 Lossless
    else if(transferSyntax === &quot;1.2.840.10008.1.2.4.90&quot;)
    {
      return cornerstoneWADOImageLoader.decodeJPEG2000(dataSet, frame);
    }
    // JPEG 2000 Lossy
    else if(transferSyntax === &quot;1.2.840.10008.1.2.4.91&quot;)
    {
      return cornerstoneWADOImageLoader.decodeJPEG2000(dataSet, frame);
    }
    /* Don&apos;t know if these work...
    // JPEG 2000 Part 2 Multicomponent Image Compression (Lossless Only)
    else if(transferSyntax === &quot;1.2.840.10008.1.2.4.92&quot;)
    {
      return cornerstoneWADOImageLoader.decodeJPEG2000(dataSet, frame);
    }
    // JPEG 2000 Part 2 Multicomponent Image Compression
    else if(transferSyntax === &quot;1.2.840.10008.1.2.4.93&quot;)
    {
      return cornerstoneWADOImageLoader.decodeJPEG2000(dataSet, frame);
    }
    */
    // RLE Lossless
    else if ( transferSyntax === &quot;1.2.840.10008.1.2.5&quot; )
    {
      return cornerstoneWADOImageLoader.decodeRLE( dataSet, frame);
    }
    // JPEG Baseline lossy process 1 (8 bit)
    else if ( transferSyntax === &quot;1.2.840.10008.1.2.4.50&quot; )
    {
      return cornerstoneWADOImageLoader.decodeJPEGBaseline(dataSet, frame);
    }
    // JPEG Baseline lossy process 2 &amp; 4 (12 bit)
    else if ( transferSyntax === &quot;1.2.840.10008.1.2.4.51&quot; )
    {
      return cornerstoneWADOImageLoader.decodeJPEGBaseline(dataSet, frame);
    }
    // JPEG Lossless, Nonhierarchical (Processes 14)
    else if ( transferSyntax === &quot;1.2.840.10008.1.2.4.57&quot; )
    {
      return cornerstoneWADOImageLoader.decodeJPEGLossless(dataSet, frame);
    }
    // JPEG Lossless, Nonhierarchical (Processes 14 [Selection 1])
    else if ( transferSyntax === &quot;1.2.840.10008.1.2.4.70&quot; )
    {
      return cornerstoneWADOImageLoader.decodeJPEGLossless(dataSet, frame);
    }
    else
    {
      throw &quot;no decoder for transfer syntax &quot; + transferSyntax;
    }
  }

  // module exports
  cornerstoneWADOImageLoader.decodeTransferSyntax = decodeTransferSyntax;

}(cornerstoneWADOImageLoader));
// jshint ignore: start

/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /
 /* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
 Copyright 2011 notmasteryet

 Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

// - The JPEG specification can be found in the ITU CCITT Recommendation T.81
//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)
// - The JFIF specification can be found in the JPEG File Interchange Format
//   (www.w3.org/Graphics/JPEG/jfif3.pdf)
// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters
//   in PostScript Level 2, Technical Note #5116
//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)

var ColorSpace = {Unkown: 0, Grayscale: 1, AdobeRGB: 2, RGB: 3, CYMK: 4};
var JpegImage = (function jpegImage() {
  &quot;use strict&quot;;
  var dctZigZag = new Int32Array([
    0,
    1, 8,
    16, 9, 2,
    3, 10, 17, 24,
    32, 25, 18, 11, 4,
    5, 12, 19, 26, 33, 40,
    48, 41, 34, 27, 20, 13, 6,
    7, 14, 21, 28, 35, 42, 49, 56,
    57, 50, 43, 36, 29, 22, 15,
    23, 30, 37, 44, 51, 58,
    59, 52, 45, 38, 31,
    39, 46, 53, 60,
    61, 54, 47,
    55, 62,
    63
  ]);

  var dctCos1 = 4017;   // cos(pi/16)
  var dctSin1 = 799;   // sin(pi/16)
  var dctCos3 = 3406;   // cos(3*pi/16)
  var dctSin3 = 2276;   // sin(3*pi/16)
  var dctCos6 = 1567;   // cos(6*pi/16)
  var dctSin6 = 3784;   // sin(6*pi/16)
  var dctSqrt2 = 5793;   // sqrt(2)
  var dctSqrt1d2 = 2896;  // sqrt(2) / 2

  function constructor() {
  }

  function buildHuffmanTable(codeLengths, values) {
    var k = 0, code = [], i, j, length = 16;
    while (length &gt; 0 &amp;&amp; !codeLengths[length - 1])
      length--;
    code.push({children: [], index: 0});
    var p = code[0], q;
    for (i = 0; i &lt; length; i++) {
      for (j = 0; j &lt; codeLengths[i]; j++) {
        p = code.pop();
        p.children[p.index] = values[k];
        while (p.index &gt; 0) {
          p = code.pop();
        }
        p.index++;
        code.push(p);
        while (code.length &lt;= i) {
          code.push(q = {children: [], index: 0});
          p.children[p.index] = q.children;
          p = q;
        }
        k++;
      }
      if (i + 1 &lt; length) {
        // p here points to last code
        code.push(q = {children: [], index: 0});
        p.children[p.index] = q.children;
        p = q;
      }
    }
    return code[0].children;
  }

  function getBlockBufferOffset(component, row, col) {
    return 64 * ((component.blocksPerLine + 1) * row + col);
  }

  function decodeScan(data, offset,
                      frame, components, resetInterval,
                      spectralStart, spectralEnd,
                      successivePrev, successive) {
    var precision = frame.precision;
    var samplesPerLine = frame.samplesPerLine;
    var scanLines = frame.scanLines;
    var mcusPerLine = frame.mcusPerLine;
    var progressive = frame.progressive;
    var maxH = frame.maxH, maxV = frame.maxV;

    var startOffset = offset, bitsData = 0, bitsCount = 0;

    function readBit() {
      if (bitsCount &gt; 0) {
        bitsCount--;
        return (bitsData &gt;&gt; bitsCount) &amp; 1;
      }
      bitsData = data[offset++];
      if (bitsData == 0xFF) {
        var nextByte = data[offset++];
        if (nextByte) {
          throw &quot;unexpected marker: &quot; + ((bitsData &lt;&lt; 8) | nextByte).toString(16);
        }
        // unstuff 0
      }
      bitsCount = 7;
      return bitsData &gt;&gt;&gt; 7;
    }

    function decodeHuffman(tree) {
      var node = tree;
      var bit;
      while ((bit = readBit()) !== null) {
        node = node[bit];
        if (typeof node === &apos;number&apos;)
          return node;
        if (typeof node !== &apos;object&apos;)
          throw &quot;invalid huffman sequence&quot;;
      }
      return null;
    }

    function receive(length) {
      var n = 0;
      while (length &gt; 0) {
        var bit = readBit();
        if (bit === null)
          return;
        n = (n &lt;&lt; 1) | bit;
        length--;
      }
      return n;
    }

    function receiveAndExtend(length) {
      var n = receive(length);
      if (n &gt;= 1 &lt;&lt; (length - 1))
        return n;
      return n + (-1 &lt;&lt; length) + 1;
    }

    function decodeBaseline(component, offset) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : receiveAndExtend(t);
      component.blockData[offset] = (component.pred += diff);
      var k = 1;
      while (k &lt; 64) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs &amp; 15, r = rs &gt;&gt; 4;
        if (s === 0) {
          if (r &lt; 15)
            break;
          k += 16;
          continue;
        }
        k += r;
        var z = dctZigZag[k];
        component.blockData[offset + z] = receiveAndExtend(s);
        k++;
      }
    }

    function decodeDCFirst(component, offset) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : (receiveAndExtend(t) &lt;&lt; successive);
      component.blockData[offset] = (component.pred += diff);
    }

    function decodeDCSuccessive(component, offset) {
      component.blockData[offset] |= readBit() &lt;&lt; successive;
    }

    var eobrun = 0;
    function decodeACFirst(component, offset) {
      if (eobrun &gt; 0) {
        eobrun--;
        return;
      }
      var k = spectralStart, e = spectralEnd;
      while (k &lt;= e) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs &amp; 15, r = rs &gt;&gt; 4;
        if (s === 0) {
          if (r &lt; 15) {
            eobrun = receive(r) + (1 &lt;&lt; r) - 1;
            break;
          }
          k += 16;
          continue;
        }
        k += r;
        var z = dctZigZag[k];
        component.blockData[offset + z] = receiveAndExtend(s) * (1 &lt;&lt; successive);
        k++;
      }
    }

    var successiveACState = 0, successiveACNextValue;
    function decodeACSuccessive(component, offset) {
      var k = spectralStart, e = spectralEnd, r = 0;
      while (k &lt;= e) {
        var z = dctZigZag[k];
        switch (successiveACState) {
          case 0: // initial state
            var rs = decodeHuffman(component.huffmanTableAC);
            var s = rs &amp; 15;
            r = rs &gt;&gt; 4;
            if (s === 0) {
              if (r &lt; 15) {
                eobrun = receive(r) + (1 &lt;&lt; r);
                successiveACState = 4;
              } else {
                r = 16;
                successiveACState = 1;
              }
            } else {
              if (s !== 1)
                throw &quot;invalid ACn encoding&quot;;
              successiveACNextValue = receiveAndExtend(s);
              successiveACState = r ? 2 : 3;
            }
            continue;
          case 1: // skipping r zero items
          case 2:
            if (component.blockData[offset + z]) {
              component.blockData[offset + z] += (readBit() &lt;&lt; successive);
            } else {
              r--;
              if (r === 0)
                successiveACState = successiveACState == 2 ? 3 : 0;
            }
            break;
          case 3: // set value for a zero item
            if (component.blockData[offset + z]) {
              component.blockData[offset + z] += (readBit() &lt;&lt; successive);
            } else {
              component.blockData[offset + z] = successiveACNextValue &lt;&lt; successive;
              successiveACState = 0;
            }
            break;
          case 4: // eob
            if (component.blockData[offset + z]) {
              component.blockData[offset + z] += (readBit() &lt;&lt; successive);
            }
            break;
        }
        k++;
      }
      if (successiveACState === 4) {
        eobrun--;
        if (eobrun === 0)
          successiveACState = 0;
      }
    }

    function decodeMcu(component, decode, mcu, row, col) {
      var mcuRow = (mcu / mcusPerLine) | 0;
      var mcuCol = mcu % mcusPerLine;
      var blockRow = mcuRow * component.v + row;
      var blockCol = mcuCol * component.h + col;
      var offset = getBlockBufferOffset(component, blockRow, blockCol);
      decode(component, offset);
    }

    function decodeBlock(component, decode, mcu) {
      var blockRow = (mcu / component.blocksPerLine) | 0;
      var blockCol = mcu % component.blocksPerLine;
      var offset = getBlockBufferOffset(component, blockRow, blockCol);
      decode(component, offset);
    }

    var componentsLength = components.length;
    var component, i, j, k, n;
    var decodeFn;
    if (progressive) {
      if (spectralStart === 0)
        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
      else
        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
    } else {
      decodeFn = decodeBaseline;
    }

    var mcu = 0, marker;
    var mcuExpected;
    if (componentsLength == 1) {
      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
    } else {
      mcuExpected = mcusPerLine * frame.mcusPerColumn;
    }
    if (!resetInterval) {
      resetInterval = mcuExpected;
    }

    var h, v;
    while (mcu &lt; mcuExpected) {
      // reset interval stuff
      for (i = 0; i &lt; componentsLength; i++) {
        components[i].pred = 0;
      }
      eobrun = 0;

      if (componentsLength == 1) {
        component = components[0];
        for (n = 0; n &lt; resetInterval; n++) {
          decodeBlock(component, decodeFn, mcu);
          mcu++;
        }
      } else {
        for (n = 0; n &lt; resetInterval; n++) {
          for (i = 0; i &lt; componentsLength; i++) {
            component = components[i];
            h = component.h;
            v = component.v;
            for (j = 0; j &lt; v; j++) {
              for (k = 0; k &lt; h; k++) {
                decodeMcu(component, decodeFn, mcu, j, k);
              }
            }
          }
          mcu++;
        }
      }

      // find marker
      bitsCount = 0;
      marker = (data[offset] &lt;&lt; 8) | data[offset + 1];
      if (marker &lt;= 0xFF00) {
        throw &quot;marker was not found&quot;;
      }

      if (marker &gt;= 0xFFD0 &amp;&amp; marker &lt;= 0xFFD7) { // RSTx
        offset += 2;
      } else {
        break;
      }
    }

    return offset - startOffset;
  }

  // A port of poppler&apos;s IDCT method which in turn is taken from:
  //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
  //   &quot;Practical Fast 1-D DCT Algorithms with 11 Multiplications&quot;,
  //   IEEE Intl. Conf. on Acoustics, Speech &amp; Signal Processing, 1989,
  //   988-991.
  function quantizeAndInverse(component, blockBufferOffset, p) {
    var qt = component.quantizationTable;
    var v0, v1, v2, v3, v4, v5, v6, v7, t;
    var i;

    // dequant
    for (i = 0; i &lt; 64; i++) {
      p[i] = component.blockData[blockBufferOffset + i] * qt[i];
    }

    // inverse DCT on rows
    for (i = 0; i &lt; 8; ++i) {
      var row = 8 * i;

      // check for all-zero AC coefficients
      if (p[1 + row] === 0 &amp;&amp; p[2 + row] === 0 &amp;&amp; p[3 + row] === 0 &amp;&amp;
        p[4 + row] === 0 &amp;&amp; p[5 + row] === 0 &amp;&amp; p[6 + row] === 0 &amp;&amp;
        p[7 + row] === 0) {
        t = (dctSqrt2 * p[0 + row] + 512) &gt;&gt; 10;
        p[0 + row] = t;
        p[1 + row] = t;
        p[2 + row] = t;
        p[3 + row] = t;
        p[4 + row] = t;
        p[5 + row] = t;
        p[6 + row] = t;
        p[7 + row] = t;
        continue;
      }

      // stage 4
      v0 = (dctSqrt2 * p[0 + row] + 128) &gt;&gt; 8;
      v1 = (dctSqrt2 * p[4 + row] + 128) &gt;&gt; 8;
      v2 = p[2 + row];
      v3 = p[6 + row];
      v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) &gt;&gt; 8;
      v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) &gt;&gt; 8;
      v5 = p[3 + row] &lt;&lt; 4;
      v6 = p[5 + row] &lt;&lt; 4;

      // stage 3
      t = (v0 - v1 + 1) &gt;&gt; 1;
      v0 = (v0 + v1 + 1) &gt;&gt; 1;
      v1 = t;
      t = (v2 * dctSin6 + v3 * dctCos6 + 128) &gt;&gt; 8;
      v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) &gt;&gt; 8;
      v3 = t;
      t = (v4 - v6 + 1) &gt;&gt; 1;
      v4 = (v4 + v6 + 1) &gt;&gt; 1;
      v6 = t;
      t = (v7 + v5 + 1) &gt;&gt; 1;
      v5 = (v7 - v5 + 1) &gt;&gt; 1;
      v7 = t;

      // stage 2
      t = (v0 - v3 + 1) &gt;&gt; 1;
      v0 = (v0 + v3 + 1) &gt;&gt; 1;
      v3 = t;
      t = (v1 - v2 + 1) &gt;&gt; 1;
      v1 = (v1 + v2 + 1) &gt;&gt; 1;
      v2 = t;
      t = (v4 * dctSin3 + v7 * dctCos3 + 2048) &gt;&gt; 12;
      v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) &gt;&gt; 12;
      v7 = t;
      t = (v5 * dctSin1 + v6 * dctCos1 + 2048) &gt;&gt; 12;
      v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) &gt;&gt; 12;
      v6 = t;

      // stage 1
      p[0 + row] = v0 + v7;
      p[7 + row] = v0 - v7;
      p[1 + row] = v1 + v6;
      p[6 + row] = v1 - v6;
      p[2 + row] = v2 + v5;
      p[5 + row] = v2 - v5;
      p[3 + row] = v3 + v4;
      p[4 + row] = v3 - v4;
    }

    // inverse DCT on columns
    for (i = 0; i &lt; 8; ++i) {
      var col = i;

      // check for all-zero AC coefficients
      if (p[1 * 8 + col] === 0 &amp;&amp; p[2 * 8 + col] === 0 &amp;&amp; p[3 * 8 + col] === 0 &amp;&amp;
        p[4 * 8 + col] === 0 &amp;&amp; p[5 * 8 + col] === 0 &amp;&amp; p[6 * 8 + col] === 0 &amp;&amp;
        p[7 * 8 + col] === 0) {
        t = (dctSqrt2 * p[i + 0] + 8192) &gt;&gt; 14;
        p[0 * 8 + col] = t;
        p[1 * 8 + col] = t;
        p[2 * 8 + col] = t;
        p[3 * 8 + col] = t;
        p[4 * 8 + col] = t;
        p[5 * 8 + col] = t;
        p[6 * 8 + col] = t;
        p[7 * 8 + col] = t;
        continue;
      }

      // stage 4
      v0 = (dctSqrt2 * p[0 * 8 + col] + 2048) &gt;&gt; 12;
      v1 = (dctSqrt2 * p[4 * 8 + col] + 2048) &gt;&gt; 12;
      v2 = p[2 * 8 + col];
      v3 = p[6 * 8 + col];
      v4 = (dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048) &gt;&gt; 12;
      v7 = (dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048) &gt;&gt; 12;
      v5 = p[3 * 8 + col];
      v6 = p[5 * 8 + col];

      // stage 3
      t = (v0 - v1 + 1) &gt;&gt; 1;
      v0 = (v0 + v1 + 1) &gt;&gt; 1;
      v1 = t;
      t = (v2 * dctSin6 + v3 * dctCos6 + 2048) &gt;&gt; 12;
      v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) &gt;&gt; 12;
      v3 = t;
      t = (v4 - v6 + 1) &gt;&gt; 1;
      v4 = (v4 + v6 + 1) &gt;&gt; 1;
      v6 = t;
      t = (v7 + v5 + 1) &gt;&gt; 1;
      v5 = (v7 - v5 + 1) &gt;&gt; 1;
      v7 = t;

      // stage 2
      t = (v0 - v3 + 1) &gt;&gt; 1;
      v0 = (v0 + v3 + 1) &gt;&gt; 1;
      v3 = t;
      t = (v1 - v2 + 1) &gt;&gt; 1;
      v1 = (v1 + v2 + 1) &gt;&gt; 1;
      v2 = t;
      t = (v4 * dctSin3 + v7 * dctCos3 + 2048) &gt;&gt; 12;
      v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) &gt;&gt; 12;
      v7 = t;
      t = (v5 * dctSin1 + v6 * dctCos1 + 2048) &gt;&gt; 12;
      v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) &gt;&gt; 12;
      v6 = t;

      // stage 1
      p[0 * 8 + col] = v0 + v7;
      p[7 * 8 + col] = v0 - v7;
      p[1 * 8 + col] = v1 + v6;
      p[6 * 8 + col] = v1 - v6;
      p[2 * 8 + col] = v2 + v5;
      p[5 * 8 + col] = v2 - v5;
      p[3 * 8 + col] = v3 + v4;
      p[4 * 8 + col] = v3 - v4;
    }

    // convert to 8-bit integers
    for (i = 0; i &lt; 64; ++i) {
      var index = blockBufferOffset + i;
      var q = p[i];
      q = (q &lt;= -2056 / component.bitConversion) ? 0 :
        (q &gt;= 2024 / component.bitConversion) ? 255 / component.bitConversion :
        (q + 2056 / component.bitConversion) &gt;&gt; 4;
      component.blockData[index] = q;
    }
  }

  function buildComponentData(frame, component) {
    var lines = [];
    var blocksPerLine = component.blocksPerLine;
    var blocksPerColumn = component.blocksPerColumn;
    var samplesPerLine = blocksPerLine &lt;&lt; 3;
    var computationBuffer = new Int32Array(64);

    var i, j, ll = 0;
    for (var blockRow = 0; blockRow &lt; blocksPerColumn; blockRow++) {
      for (var blockCol = 0; blockCol &lt; blocksPerLine; blockCol++) {
        var offset = getBlockBufferOffset(component, blockRow, blockCol);
        quantizeAndInverse(component, offset, computationBuffer);
      }
    }
    return component.blockData;
  }

  function clampToUint8(a) {
    return a &lt;= 0 ? 0 : a &gt;= 255 ? 255 : a | 0;
  }

  constructor.prototype = {
    load: function load(path) {
      var handleData = (function (data) {
        this.parse(data);
        if (this.onload)
          this.onload();
      }).bind(this);

      if (path.indexOf(&quot;data:&quot;) &gt; -1) {
        var offset = path.indexOf(&quot;base64,&quot;) + 7;
        var data = atob(path.substring(offset));
        var arr = new Uint8Array(data.length);
        for (var i = data.length - 1; i &gt;= 0; i--) {
          arr[i] = data.charCodeAt(i);
        }
        handleData(data);
      } else {
        var xhr = new XMLHttpRequest();
        xhr.open(&quot;GET&quot;, path, true);
        xhr.responseType = &quot;arraybuffer&quot;;
        xhr.onload = (function () {
          // TODO catch parse error
          var data = new Uint8Array(xhr.response);
          handleData(data);
        }).bind(this);
        xhr.send(null);
      }
    },
    parse: function parse(data) {

      function readUint16() {
        var value = (data[offset] &lt;&lt; 8) | data[offset + 1];
        offset += 2;
        return value;
      }

      function readDataBlock() {
        var length = readUint16();
        var array = data.subarray(offset, offset + length - 2);
        offset += array.length;
        return array;
      }

      function prepareComponents(frame) {
        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);
        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);
        for (var i = 0; i &lt; frame.components.length; i++) {
          component = frame.components[i];
          var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / frame.maxH);
          var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / frame.maxV);
          var blocksPerLineForMcu = mcusPerLine * component.h;
          var blocksPerColumnForMcu = mcusPerColumn * component.v;

          var blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);
          component.blockData = new Int16Array(blocksBufferSize);
          component.blocksPerLine = blocksPerLine;
          component.blocksPerColumn = blocksPerColumn;
        }
        frame.mcusPerLine = mcusPerLine;
        frame.mcusPerColumn = mcusPerColumn;
      }

      var offset = 0, length = data.length;
      var jfif = null;
      var adobe = null;
      var pixels = null;
      var frame, resetInterval;
      var quantizationTables = [];
      var huffmanTablesAC = [], huffmanTablesDC = [];
      var fileMarker = readUint16();
      if (fileMarker != 0xFFD8) { // SOI (Start of Image)
        throw &quot;SOI not found&quot;;
      }

      fileMarker = readUint16();
      while (fileMarker != 0xFFD9) { // EOI (End of image)
        var i, j, l;
        switch (fileMarker) {
          case 0xFFE0: // APP0 (Application Specific)
          case 0xFFE1: // APP1
          case 0xFFE2: // APP2
          case 0xFFE3: // APP3
          case 0xFFE4: // APP4
          case 0xFFE5: // APP5
          case 0xFFE6: // APP6
          case 0xFFE7: // APP7
          case 0xFFE8: // APP8
          case 0xFFE9: // APP9
          case 0xFFEA: // APP10
          case 0xFFEB: // APP11
          case 0xFFEC: // APP12
          case 0xFFED: // APP13
          case 0xFFEE: // APP14
          case 0xFFEF: // APP15
          case 0xFFFE: // COM (Comment)
            var appData = readDataBlock();

            if (fileMarker === 0xFFE0) {
              if (appData[0] === 0x4A &amp;&amp; appData[1] === 0x46 &amp;&amp; appData[2] === 0x49 &amp;&amp;
                appData[3] === 0x46 &amp;&amp; appData[4] === 0) { // &apos;JFIF\x00&apos;
                jfif = {
                  version: {major: appData[5], minor: appData[6]},
                  densityUnits: appData[7],
                  xDensity: (appData[8] &lt;&lt; 8) | appData[9],
                  yDensity: (appData[10] &lt;&lt; 8) | appData[11],
                  thumbWidth: appData[12],
                  thumbHeight: appData[13],
                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                };
              }
            }
            // TODO APP1 - Exif
            if (fileMarker === 0xFFEE) {
              if (appData[0] === 0x41 &amp;&amp; appData[1] === 0x64 &amp;&amp; appData[2] === 0x6F &amp;&amp;
                appData[3] === 0x62 &amp;&amp; appData[4] === 0x65 &amp;&amp; appData[5] === 0) { // &apos;Adobe\x00&apos;
                adobe = {
                  version: appData[6],
                  flags0: (appData[7] &lt;&lt; 8) | appData[8],
                  flags1: (appData[9] &lt;&lt; 8) | appData[10],
                  transformCode: appData[11]
                };
              }
            }
            break;

          case 0xFFDB: // DQT (Define Quantization Tables)
            var quantizationTablesLength = readUint16();
            var quantizationTablesEnd = quantizationTablesLength + offset - 2;
            while (offset &lt; quantizationTablesEnd) {
              var quantizationTableSpec = data[offset++];
              var tableData = new Int32Array(64);
              if ((quantizationTableSpec &gt;&gt; 4) === 0) { // 8 bit values
                for (j = 0; j &lt; 64; j++) {
                  var z = dctZigZag[j];
                  tableData[z] = data[offset++];
                }
              } else if ((quantizationTableSpec &gt;&gt; 4) === 1) { //16 bit
                for (j = 0; j &lt; 64; j++) {
                  var zz = dctZigZag[j];
                  tableData[zz] = readUint16();
                }
              } else
                throw &quot;DQT: invalid table spec&quot;;
              quantizationTables[quantizationTableSpec &amp; 15] = tableData;
            }
            break;

          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)
          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)
          case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)
            if (frame) {
              throw &quot;Only single frame JPEGs supported&quot;;
            }
            readUint16(); // skip data length
            frame = {};
            frame.extended = (fileMarker === 0xFFC1);
            frame.progressive = (fileMarker === 0xFFC2);
            frame.precision = data[offset++];
            frame.scanLines = readUint16();
            frame.samplesPerLine = readUint16();
            frame.components = [];
            frame.componentIds = {};
            var componentsCount = data[offset++], componentId;
            var maxH = 0, maxV = 0;
            for (i = 0; i &lt; componentsCount; i++) {
              componentId = data[offset];
              var h = data[offset + 1] &gt;&gt; 4;
              var v = data[offset + 1] &amp; 15;
              if (maxH &lt; h)
                maxH = h;
              if (maxV &lt; v)
                maxV = v;
              var qId = data[offset + 2];
              l = frame.components.push({
                h: h,
                v: v,
                quantizationTable: quantizationTables[qId],
                quantizationTableId: qId,
                bitConversion: 255 / ((1 &lt;&lt; frame.precision) - 1)
              });
              frame.componentIds[componentId] = l - 1;
              offset += 3;
            }
            frame.maxH = maxH;
            frame.maxV = maxV;
            prepareComponents(frame);
            break;

          case 0xFFC4: // DHT (Define Huffman Tables)
            var huffmanLength = readUint16();
            for (i = 2; i &lt; huffmanLength; ) {
              var huffmanTableSpec = data[offset++];
              var codeLengths = new Uint8Array(16);
              var codeLengthSum = 0;
              for (j = 0; j &lt; 16; j++, offset++)
                codeLengthSum += (codeLengths[j] = data[offset]);
              var huffmanValues = new Uint8Array(codeLengthSum);
              for (j = 0; j &lt; codeLengthSum; j++, offset++)
                huffmanValues[j] = data[offset];
              i += 17 + codeLengthSum;

              ((huffmanTableSpec &gt;&gt; 4) === 0 ?
                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec &amp; 15] =
                buildHuffmanTable(codeLengths, huffmanValues);
            }
            break;

          case 0xFFDD: // DRI (Define Restart Interval)
            readUint16(); // skip data length
            resetInterval = readUint16();
            break;

          case 0xFFDA: // SOS (Start of Scan)
            var scanLength = readUint16();
            var selectorsCount = data[offset++];
            var components = [], component;
            for (i = 0; i &lt; selectorsCount; i++) {
              var componentIndex = frame.componentIds[data[offset++]];
              component = frame.components[componentIndex];
              var tableSpec = data[offset++];
              component.huffmanTableDC = huffmanTablesDC[tableSpec &gt;&gt; 4];
              component.huffmanTableAC = huffmanTablesAC[tableSpec &amp; 15];
              components.push(component);
            }
            var spectralStart = data[offset++];
            var spectralEnd = data[offset++];
            var successiveApproximation = data[offset++];
            var processed = decodeScan(data, offset,
              frame, components, resetInterval,
              spectralStart, spectralEnd,
              successiveApproximation &gt;&gt; 4, successiveApproximation &amp; 15);
            offset += processed;
            break;
          default:
            if (data[offset - 3] == 0xFF &amp;&amp;
              data[offset - 2] &gt;= 0xC0 &amp;&amp; data[offset - 2] &lt;= 0xFE) {
              // could be incorrect encoding -- last 0xFF byte of the previous
              // block was eaten by the encoder
              offset -= 3;
              break;
            }
            throw &quot;unknown JPEG marker &quot; + fileMarker.toString(16);
        }
        fileMarker = readUint16();
      }

      this.width = frame.samplesPerLine;
      this.height = frame.scanLines;
      this.jfif = jfif;
      this.adobe = adobe;
      this.components = [];
      switch (frame.components.length)
      {
        case 1:
          this.colorspace = ColorSpace.Grayscale;
          break;
        case 3:
          if (this.adobe)
            this.colorspace = ColorSpace.AdobeRGB;
          else
            this.colorspace = ColorSpace.RGB;
          break;
        case 4:
          this.colorspace = ColorSpace.CYMK;
          break;
        default:
          this.colorspace = ColorSpace.Unknown;
      }
      for (var i = 0; i &lt; frame.components.length; i++) {
        var component = frame.components[i];
        if (!component.quantizationTable &amp;&amp; component.quantizationTableId !== null)
          component.quantizationTable = quantizationTables[component.quantizationTableId];
        this.components.push({
          output: buildComponentData(frame, component),
          scaleX: component.h / frame.maxH,
          scaleY: component.v / frame.maxV,
          blocksPerLine: component.blocksPerLine,
          blocksPerColumn: component.blocksPerColumn,
          bitConversion: component.bitConversion
        });
      }
    },
    getData16: function getData16(width, height) {
      if (this.components.length !== 1)
        throw &apos;Unsupported color mode&apos;;
      var scaleX = this.width / width, scaleY = this.height / height;

      var component, componentScaleX, componentScaleY;
      var x, y, i;
      var offset = 0;
      var numComponents = this.components.length;
      var dataLength = width * height * numComponents;
      var data = new Uint16Array(dataLength);
      var componentLine;

      // lineData is reused for all components. Assume first component is
      // the biggest
      var lineData = new Uint16Array((this.components[0].blocksPerLine &lt;&lt; 3) *
      this.components[0].blocksPerColumn * 8);

      // First construct image data ...
      for (i = 0; i &lt; numComponents; i++) {
        component = this.components[i];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine &lt;&lt; 3;

        var j, k, ll = 0;
        var lineOffset = 0;
        for (var blockRow = 0; blockRow &lt; blocksPerColumn; blockRow++) {
          var scanLine = blockRow &lt;&lt; 3;
          for (var blockCol = 0; blockCol &lt; blocksPerLine; blockCol++) {
            var bufferOffset = getBlockBufferOffset(component, blockRow, blockCol);
            var offset = 0, sample = blockCol &lt;&lt; 3;
            for (j = 0; j &lt; 8; j++) {
              var lineOffset = (scanLine + j) * samplesPerLine;
              for (k = 0; k &lt; 8; k++) {
                lineData[lineOffset + sample + k] =
                  component.output[bufferOffset + offset++];
              }
            }
          }
        }

        componentScaleX = component.scaleX * scaleX;
        componentScaleY = component.scaleY * scaleY;
        offset = i;

        var cx, cy;
        var index;
        for (y = 0; y &lt; height; y++) {
          for (x = 0; x &lt; width; x++) {
            cy = 0 | (y * componentScaleY);
            cx = 0 | (x * componentScaleX);
            index = cy * samplesPerLine + cx;
            data[offset] = lineData[index];
            offset += numComponents;
          }
        }
      }
      return data;
    },
    getData: function getData(width, height) {
      var scaleX = this.width / width, scaleY = this.height / height;

      var component, componentScaleX, componentScaleY;
      var x, y, i;
      var offset = 0;
      var Y, Cb, Cr, K, C, M, Ye, R, G, B;
      var colorTransform;
      var numComponents = this.components.length;
      var dataLength = width * height * numComponents;
      var data = new Uint8Array(dataLength);
      var componentLine;

      // lineData is reused for all components. Assume first component is
      // the biggest
      var lineData = new Uint8Array((this.components[0].blocksPerLine &lt;&lt; 3) *
      this.components[0].blocksPerColumn * 8);

      // First construct image data ...
      for (i = 0; i &lt; numComponents; i++) {
        component = this.components[i];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine &lt;&lt; 3;

        var j, k, ll = 0;
        var lineOffset = 0;
        for (var blockRow = 0; blockRow &lt; blocksPerColumn; blockRow++) {
          var scanLine = blockRow &lt;&lt; 3;
          for (var blockCol = 0; blockCol &lt; blocksPerLine; blockCol++) {
            var bufferOffset = getBlockBufferOffset(component, blockRow, blockCol);
            var offset = 0, sample = blockCol &lt;&lt; 3;
            for (j = 0; j &lt; 8; j++) {
              var lineOffset = (scanLine + j) * samplesPerLine;
              for (k = 0; k &lt; 8; k++) {
                lineData[lineOffset + sample + k] =
                  component.output[bufferOffset + offset++] * component.bitConversion;
              }
            }
          }
        }

        componentScaleX = component.scaleX * scaleX;
        componentScaleY = component.scaleY * scaleY;
        offset = i;

        var cx, cy;
        var index;
        for (y = 0; y &lt; height; y++) {
          for (x = 0; x &lt; width; x++) {
            cy = 0 | (y * componentScaleY);
            cx = 0 | (x * componentScaleX);
            index = cy * samplesPerLine + cx;
            data[offset] = lineData[index];
            offset += numComponents;
          }
        }
      }

      // ... then transform colors, if necessary
      switch (numComponents) {
        case 1:
        case 2:
          break;
        // no color conversion for one or two compoenents

        case 3:
          // The default transform for three components is true
          colorTransform = true;
          // The adobe transform marker overrides any previous setting
          if (this.adobe &amp;&amp; this.adobe.transformCode)
            colorTransform = true;
          else if (typeof this.colorTransform !== &apos;undefined&apos;)
            colorTransform = !!this.colorTransform;

          if (colorTransform) {
            for (i = 0; i &lt; dataLength; i += numComponents) {
              Y = data[i    ];
              Cb = data[i + 1];
              Cr = data[i + 2];

              R = clampToUint8(Y - 179.456 + 1.402 * Cr);
              G = clampToUint8(Y + 135.459 - 0.344 * Cb - 0.714 * Cr);
              B = clampToUint8(Y - 226.816 + 1.772 * Cb);

              data[i    ] = R;
              data[i + 1] = G;
              data[i + 2] = B;
            }
          }
          break;
        case 4:
          if (!this.adobe)
            throw &apos;Unsupported color mode (4 components)&apos;;
          // The default transform for four components is false
          colorTransform = false;
          // The adobe transform marker overrides any previous setting
          if (this.adobe &amp;&amp; this.adobe.transformCode)
            colorTransform = true;
          else if (typeof this.colorTransform !== &apos;undefined&apos;)
            colorTransform = !!this.colorTransform;

          if (colorTransform) {
            for (i = 0; i &lt; dataLength; i += numComponents) {
              Y = data[i];
              Cb = data[i + 1];
              Cr = data[i + 2];

              C = clampToUint8(434.456 - Y - 1.402 * Cr);
              M = clampToUint8(119.541 - Y + 0.344 * Cb + 0.714 * Cr);
              Y = clampToUint8(481.816 - Y - 1.772 * Cb);

              data[i    ] = C;
              data[i + 1] = M;
              data[i + 2] = Y;
              // K is unchanged
            }
          }
          break;
        default:
          throw &apos;Unsupported color mode&apos;;
      }
      return data;
    }
  };

  return constructor;
})();
(function(f){if(typeof exports===&quot;object&quot;&amp;&amp;typeof module!==&quot;undefined&quot;){module.exports=f()}else if(typeof define===&quot;function&quot;&amp;&amp;define.amd){define([],f)}else{var g;if(typeof window!==&quot;undefined&quot;){g=window}else if(typeof global!==&quot;undefined&quot;){g=global}else if(typeof self!==&quot;undefined&quot;){g=self}else{g=this}g.jpeg = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==&quot;function&quot;&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);var f=new Error(&quot;Cannot find module &apos;&quot;+o+&quot;&apos;&quot;);throw f.code=&quot;MODULE_NOT_FOUND&quot;,f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==&quot;function&quot;&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
  /*
   * Copyright (C) 2015 Michael Martinez
   * Changes: Added support for selection values 2-7, fixed minor bugs &amp;
   * warnings, split into multiple class files, and general clean up.
   *
   * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
   */

  /*
   * Copyright (C) Helmut Dersch
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the &quot;Software&quot;), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:

   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.

   * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /*jslint browser: true, node: true */
  /*global require, module */

  &quot;use strict&quot;;

  /*** Imports ***/
  var jpeg = jpeg || {};
  jpeg.lossless = jpeg.lossless || {};


  /*** Constructor ***/
  jpeg.lossless.ComponentSpec = jpeg.lossless.ComponentSpec || function () {
    this.hSamp = 0; // Horizontal sampling factor
    this.quantTableSel = 0; // Quantization table destination selector
    this.vSamp = 0; // Vertical
  };


  /*** Exports ***/

  var moduleType = typeof module;
  if ((moduleType !== &apos;undefined&apos;) &amp;&amp; module.exports) {
    module.exports = jpeg.lossless.ComponentSpec;
  }

},{}],2:[function(require,module,exports){
  /*
   * Copyright (C) 2015 Michael Martinez
   * Changes: Added support for selection values 2-7, fixed minor bugs &amp;
   * warnings, split into multiple class files, and general clean up.
   *
   * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
   */

  /*
   * Copyright (C) Helmut Dersch
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the &quot;Software&quot;), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:

   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.

   * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /*jslint browser: true, node: true */
  /*global require, module */

  &quot;use strict&quot;;

  /*** Imports ***/
  var jpeg = jpeg || {};
  jpeg.lossless = jpeg.lossless || {};


  /*** Constructor ***/
  jpeg.lossless.DataStream = jpeg.lossless.DataStream || function (data, offset, length) {
    this.buffer = new DataView(data, offset, length);
    this.index = 0;
  };



  jpeg.lossless.DataStream.prototype.get16 = function () {
    var value = this.buffer.getUint16(this.index, false);
    this.index += 2;
    return value;
  };



  jpeg.lossless.DataStream.prototype.get8 = function () {
    var value = this.buffer.getUint8(this.index);
    this.index += 1;
    return value;
  };


  /*** Exports ***/

  var moduleType = typeof module;
  if ((moduleType !== &apos;undefined&apos;) &amp;&amp; module.exports) {
    module.exports = jpeg.lossless.DataStream;
  }

},{}],3:[function(require,module,exports){
  /*
   * Copyright (C) 2015 Michael Martinez
   * Changes: Added support for selection values 2-7, fixed minor bugs &amp;
   * warnings, split into multiple class files, and general clean up.
   *
   * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
   */

  /*
   * Copyright (C) Helmut Dersch
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the &quot;Software&quot;), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:

   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.

   * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /*jslint browser: true, node: true */
  /*global require, module */

  &quot;use strict&quot;;

  /*** Imports ***/
  var jpeg = jpeg || {};
  jpeg.lossless = jpeg.lossless || {};
  jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== &apos;undefined&apos;) ? require(&apos;./data-stream.js&apos;) : null);
  jpeg.lossless.HuffmanTable = jpeg.lossless.HuffmanTable || ((typeof require !== &apos;undefined&apos;) ? require(&apos;./huffman-table.js&apos;) : null);
  jpeg.lossless.QuantizationTable = jpeg.lossless.QuantizationTable || ((typeof require !== &apos;undefined&apos;) ? require(&apos;./quantization-table.js&apos;) : null);
  jpeg.lossless.ScanHeader = jpeg.lossless.ScanHeader || ((typeof require !== &apos;undefined&apos;) ? require(&apos;./scan-header.js&apos;) : null);
  jpeg.lossless.FrameHeader = jpeg.lossless.FrameHeader || ((typeof require !== &apos;undefined&apos;) ? require(&apos;./frame-header.js&apos;) : null);
  jpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== &apos;undefined&apos;) ? require(&apos;./utils.js&apos;) : null);


  /*** Constructor ***/
  jpeg.lossless.Decoder = jpeg.lossless.Decoder || function (buffer, numBytes) {
    this.buffer = buffer;
    this.frame = new jpeg.lossless.FrameHeader();
    this.huffTable = new jpeg.lossless.HuffmanTable();
    this.quantTable = new jpeg.lossless.QuantizationTable();
    this.scan = new jpeg.lossless.ScanHeader();
    this.DU = jpeg.lossless.Utils.createArray(10, 4, 64); // at most 10 data units in a MCU, at most 4 data units in one component
    this.HuffTab = jpeg.lossless.Utils.createArray(4, 2, 50 * 256);
    this.IDCT_Source = [];
    this.nBlock = []; // number of blocks in the i-th Comp in a scan
    this.acTab = jpeg.lossless.Utils.createArray(10, 1); // ac HuffTab for the i-th Comp in a scan
    this.dcTab = jpeg.lossless.Utils.createArray(10, 1); // dc HuffTab for the i-th Comp in a scan
    this.qTab = jpeg.lossless.Utils.createArray(10, 1); // quantization table for the i-th Comp in a scan
    this.marker = 0;
    this.markerIndex = 0;
    this.numComp = 0;
    this.restartInterval = 0;
    this.selection = 0;
    this.xDim = 0;
    this.yDim = 0;
    this.xLoc = 0;
    this.yLoc = 0;
    this.outputData = null;

    if (typeof numBytes === &quot;undefined&quot;) {
      this.numBytes = 2;
    } else {
      this.numBytes = numBytes;
    }
  };


  /*** Static Pseudo-constants ***/

  jpeg.lossless.Decoder.IDCT_P = [0, 5, 40, 16, 45, 2, 7, 42, 21, 56, 8, 61, 18, 47, 1, 4, 41, 23, 58, 13, 32, 24, 37, 10, 63, 17, 44, 3, 6, 43, 20,
    57, 15, 34, 29, 48, 53, 26, 39, 9, 60, 19, 46, 22, 59, 12, 33, 31, 50, 55, 25, 36, 11, 62, 14, 35, 28, 49, 52, 27, 38, 30, 51, 54];
  jpeg.lossless.Decoder.TABLE = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53,
    10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63];
  jpeg.lossless.Decoder.MAX_HUFFMAN_SUBTREE = 50;
  jpeg.lossless.Decoder.MSB = 0x80000000;


  /*** Prototype Methods ***/

  jpeg.lossless.Decoder.prototype.decode = function (buffer, offset, length, numBytes) {
    /*jslint bitwise: true */

    var current, scanNum = 0, pred = [], i, compN, temp = [], index = [], mcuNum;

    if (typeof buffer !== &quot;undefined&quot;) {
      this.buffer = buffer;
    }

    if (typeof numBytes !== &quot;undefined&quot;) {
      this.numBytes = numBytes;
    }

    if (this.numBytes === 2) {
      this.getter = this.getValue16;
      this.setter = this.setValue16;
    } else if (this.numBytes === 1) {
      this.getter = this.getValue8;
      this.setter = this.setValue8;
    }

    this.stream = new jpeg.lossless.DataStream(this.buffer, offset, length);
    this.buffer = null;

    this.xLoc = 0;
    this.yLoc = 0;
    current = this.stream.get16();

    if (current !== 0xFFD8) { // SOI
      throw new Error(&quot;Not a JPEG file&quot;);
    }

    current = this.stream.get16();

    while ((((current &gt;&gt; 4) !== 0x0FFC) || (current === 0xFFC4))) { // SOF 0~15
      switch (current) {
        case 0xFFC4: // DHT
          this.huffTable.read(this.stream, this.HuffTab);
          break;
        case 0xFFCC: // DAC
          throw new Error(&quot;Program doesn&apos;t support arithmetic coding. (format throw new IOException)&quot;);
        case 0xFFDB:
          this.quantTable.read(this.stream, jpeg.lossless.Decoder.TABLE);
          break;
        case 0xFFDD:
          this.restartInterval = this.readNumber();
          break;
        case 0xFFE0:
        case 0xFFE1:
        case 0xFFE2:
        case 0xFFE3:
        case 0xFFE4:
        case 0xFFE5:
        case 0xFFE6:
        case 0xFFE7:
        case 0xFFE8:
        case 0xFFE9:
        case 0xFFEA:
        case 0xFFEB:
        case 0xFFEC:
        case 0xFFED:
        case 0xFFEE:
        case 0xFFEF:
          this.readApp();
          break;
        case 0xFFFE:
          this.readComment();
          break;
        default:
          if ((current &gt;&gt; 8) !== 0xFF) {
            throw new Error(&quot;ERROR: format throw new IOException! (decode)&quot;);
          }
      }

      current = this.stream.get16();
    }

    if ((current &lt; 0xFFC0) || (current &gt; 0xFFC7)) {
      throw new Error(&quot;ERROR: could not handle arithmetic code!&quot;);
    }

    this.frame.read(this.stream);
    current = this.stream.get16();

    do {
      while (current !== 0x0FFDA) { // SOS
        switch (current) {
          case 0xFFC4: // DHT
            this.huffTable.read(this.stream, this.HuffTab);
            break;
          case 0xFFCC: // DAC
            throw new Error(&quot;Program doesn&apos;t support arithmetic coding. (format throw new IOException)&quot;);
          case 0xFFDB:
            this.quantTable.read(this.stream, jpeg.lossless.Decoder.TABLE);
            break;
          case 0xFFDD:
            this.restartInterval = this.readNumber();
            break;
          case 0xFFE0:
          case 0xFFE1:
          case 0xFFE2:
          case 0xFFE3:
          case 0xFFE4:
          case 0xFFE5:
          case 0xFFE6:
          case 0xFFE7:
          case 0xFFE8:
          case 0xFFE9:
          case 0xFFEA:
          case 0xFFEB:
          case 0xFFEC:
          case 0xFFED:
          case 0xFFEE:
          case 0xFFEF:
            this.readApp();
            break;
          case 0xFFFE:
            this.readComment();
            break;
          default:
            if ((current &gt;&gt; 8) !== 0xFF) {
              throw new Error(&quot;ERROR: format throw new IOException! (Parser.decode)&quot;);
            }
        }

        current = this.stream.get16();
      }

      this.precision = this.frame.precision;
      this.components = this.frame.components;

      this.scan.read(this.stream);
      this.numComp = this.scan.numComp;
      this.selection = this.scan.selection;

      this.scanComps = this.scan.components;
      this.quantTables = this.quantTable.quantTables;

      for (i = 0; i &lt; this.numComp; i+=1) {
        compN = this.scanComps[i].scanCompSel;
        this.qTab[i] = this.quantTables[this.components[compN].quantTableSel];
        this.nBlock[i] = this.components[compN].vSamp * this.components[compN].hSamp;
        this.dcTab[i] = this.HuffTab[this.scanComps[i].dcTabSel][0];
        this.acTab[i] = this.HuffTab[this.scanComps[i].acTabSel][1];
      }

      this.xDim = this.frame.dimX;
      this.yDim = this.frame.dimY;
      this.outputData = new DataView(new ArrayBuffer(this.xDim * this.yDim * this.numBytes));

      scanNum+=1;

      while (true) { // Decode one scan
        temp[0] = 0;
        index[0] = 0;

        for (i = 0; i &lt; 10; i+=1) {
          pred[i] = (1 &lt;&lt; (this.precision - 1));
        }

        if (this.restartInterval === 0) {
          current = this.decodeUnit(pred, temp, index);

          while ((current === 0) &amp;&amp; ((this.xLoc &lt; this.xDim) &amp;&amp; (this.yLoc &lt; this.yDim))) {
            this.output(pred);
            current = this.decodeUnit(pred, temp, index);
          }

          break; //current=MARKER
        }

        for (mcuNum = 0; mcuNum &lt; this.restartInterval; mcuNum+=1) {
          current = this.decodeUnit(pred, temp, index);
          this.output(pred);

          if (current !== 0) {
            break;
          }
        }

        if (current === 0) {
          if (this.markerIndex !== 0) {
            current = (0xFF00 | this.marker);
            this.markerIndex = 0;
          } else {
            current = this.stream.get16();
          }
        }

        if (!((current &gt;= 0xFFD0) &amp;&amp; (current &lt;= 0xFFD7))) {
          break; //current=MARKER
        }
      }

      if ((current === 0xFFDC) &amp;&amp; (scanNum === 1)) { //DNL
        this.readNumber();
        current = this.stream.get16();
      }
    } while ((current !== 0xFFD9) &amp;&amp; ((this.xLoc &lt; this.xDim) &amp;&amp; (this.yLoc &lt; this.yDim)) &amp;&amp; (scanNum === 0));

    return this.outputData;
  };



  jpeg.lossless.Decoder.prototype.decodeUnit = function (prev, temp, index) {
    /*jslint bitwise: true */

    var value, actab, dctab, qtab, ctrC, i, k, j;

    switch (this.selection) {
      case 2:
        prev[0] = this.getPreviousY();
        break;
      case 3:
        prev[0] = this.getPreviousXY();
        break;
      case 4:
        prev[0] = (this.getPreviousX() + this.getPreviousY()) - this.getPreviousXY();
        break;
      case 5:
        prev[0] = this.getPreviousX() + ((this.getPreviousY() - this.getPreviousXY()) &gt;&gt; 1);
        break;
      case 6:
        prev[0] = this.getPreviousY() + ((this.getPreviousX() - this.getPreviousXY()) &gt;&gt; 1);
        break;
      case 7:
        prev[0] = ((this.getPreviousX() + this.getPreviousY()) / 2);
        break;
      default:
        prev[0] = this.getPreviousX();
        break;
    }

    if (this.numComp &gt; 1) {
      for (ctrC = 0; ctrC &lt; this.numComp; ctrC+=1) {
        qtab = this.qTab[ctrC];
        actab = this.acTab[ctrC];
        dctab = this.dcTab[ctrC];
        for (i = 0; i &lt; this.nBlock[ctrC]; i+=1) {
          for (k = 0; k &lt; this.IDCT_Source.length; k+=1) {
            this.IDCT_Source[k] = 0;
          }

          value = this.getHuffmanValue(dctab, temp, index);

          if (value &gt;= 0xFF00) {
            return value;
          }

          prev[ctrC] = this.IDCT_Source[0] = prev[ctrC] + this.getn(index, value, temp, index);
          this.IDCT_Source[0] *= qtab[0];

          for (j = 1; j &lt; 64; j+=1) {
            value = this.getHuffmanValue(actab, temp, index);

            if (value &gt;= 0xFF00) {
              return value;
            }

            j += (value &gt;&gt; 4);

            if ((value &amp; 0x0F) === 0) {
              if ((value &gt;&gt; 4) === 0) {
                break;
              }
            } else {
              this.IDCT_Source[jpeg.lossless.Decoder.IDCT_P[j]] = this.getn(index, value &amp; 0x0F, temp, index) * qtab[j];
            }
          }

          this.scaleIDCT(this.DU[ctrC][i]);
        }
      }

      return 0;
    } else {
      for (i = 0; i &lt; this.nBlock[0]; i+=1) {
        value = this.getHuffmanValue(this.dcTab[0], temp, index);
        if (value &gt;= 0xFF00) {
          return value;
        }

        prev[0] += this.getn(prev, value, temp, index);
      }

      return 0;
    }
  };



//	Huffman table for fast search: (HuffTab) 8-bit Look up table 2-layer search architecture, 1st-layer represent 256 node (8 bits) if codeword-length &gt; 8
//	bits, then the entry of 1st-layer = (# of 2nd-layer table) | MSB and it is stored in the 2nd-layer Size of tables in each layer are 256.
//	HuffTab[*][*][0-256] is always the only 1st-layer table.
//
//	An entry can be: (1) (# of 2nd-layer table) | MSB , for code length &gt; 8 in 1st-layer (2) (Code length) &lt;&lt; 8 | HuffVal
//
//	HuffmanValue(table   HuffTab[x][y] (ex) HuffmanValue(HuffTab[1][0],...)
//	                ):
//	    return: Huffman Value of table
//	            0xFF?? if it receives a MARKER
//	    Parameter:  table   HuffTab[x][y] (ex) HuffmanValue(HuffTab[1][0],...)
//	                temp    temp storage for remainded bits
//	                index   index to bit of temp
//	                in      FILE pointer
//	    Effect:
//	        temp  store new remainded bits
//	        index change to new index
//	        in    change to new position
//	    NOTE:
//	      Initial by   temp=0; index=0;
//	    NOTE: (explain temp and index)
//	      temp: is always in the form at calling time or returning time
//	       |  byte 4  |  byte 3  |  byte 2  |  byte 1  |
//	       |     0    |     0    | 00000000 | 00000??? |  if not a MARKER
//	                                               ^index=3 (from 0 to 15)
//	                                               321
//	    NOTE (marker and marker_index):
//	      If get a MARKER from &apos;in&apos;, marker=the low-byte of the MARKER
//	        and marker_index=9
//	      If marker_index=9 then index is always &gt; 8, or HuffmanValue()
//	        will not be called
  jpeg.lossless.Decoder.prototype.getHuffmanValue = function (table, temp, index) {
    /*jslint bitwise: true */

    var code, input, mask;
    mask = 0xFFFF;

    if (index[0] &lt; 8) {
      temp[0] &lt;&lt;= 8;
      input = this.stream.get8();
      if (input === 0xFF) {
        this.marker = this.stream.get8();
        if (this.marker !== 0) {
          this.markerIndex = 9;
        }
      }
      temp[0] |= input;
    } else {
      index[0] -= 8;
    }

    code = table[temp[0] &gt;&gt; index[0]];

    if ((code &amp; jpeg.lossless.Decoder.MSB) !== 0) {
      if (this.markerIndex !== 0) {
        this.markerIndex = 0;
        return 0xFF00 | this.marker;
      }

      temp[0] &amp;= (mask &gt;&gt; (16 - index[0]));
      temp[0] &lt;&lt;= 8;
      input = this.stream.get8();

      if (input === 0xFF) {
        this.marker = this.stream.get8();
        if (this.marker !== 0) {
          this.markerIndex = 9;
        }
      }

      temp[0] |= input;
      code = table[((code &amp; 0xFF) * 256) + (temp[0] &gt;&gt; index[0])];
      index[0] += 8;
    }

    index[0] += 8 - (code &gt;&gt; 8);

    if (index[0] &lt; 0) {
      throw new Error(&quot;index=&quot; + index[0] + &quot; temp=&quot; + temp[0] + &quot; code=&quot; + code + &quot; in HuffmanValue()&quot;);
    }

    if (index[0] &lt; this.markerIndex) {
      this.markerIndex = 0;
      return 0xFF00 | this.marker;
    }

    temp[0] &amp;= (mask &gt;&gt; (16 - index[0]));
    return code &amp; 0xFF;
  };



  jpeg.lossless.Decoder.prototype.getn = function (PRED, n, temp, index) {
    /*jslint bitwise: true */

    var result, one, n_one, mask, input;
    one = 1;
    n_one = -1;
    mask = 0xFFFF;

    if (n === 0) {
      return 0;
    }

    if (n === 16) {
      if (PRED[0] &gt;= 0) {
        return -32768;
      } else {
        return 32768;
      }
    }

    index[0] -= n;

    if (index[0] &gt;= 0) {
      if ((index[0] &lt; this.markerIndex) &amp;&amp; !this.isLastPixel()) { // this was corrupting the last pixel in some cases
        this.markerIndex = 0;
        return (0xFF00 | this.marker) &lt;&lt; 8;
      }

      result = temp[0] &gt;&gt; index[0];
      temp[0] &amp;= (mask &gt;&gt; (16 - index[0]));
    } else {
      temp[0] &lt;&lt;= 8;
      input = this.stream.get8();

      if (input === 0xFF) {
        this.marker = this.stream.get8();
        if (this.marker !== 0) {
          this.markerIndex = 9;
        }
      }

      temp[0] |= input;
      index[0] += 8;

      if (index[0] &lt; 0) {
        if (this.markerIndex !== 0) {
          this.markerIndex = 0;
          return (0xFF00 | this.marker) &lt;&lt; 8;
        }

        temp[0] &lt;&lt;= 8;
        input = this.stream.get8();

        if (input === 0xFF) {
          this.marker = this.stream.get8();
          if (this.marker !== 0) {
            this.markerIndex = 9;
          }
        }

        temp[0] |= input;
        index[0] += 8;
      }

      if (index[0] &lt; 0) {
        throw new Error(&quot;index=&quot; + index[0] + &quot; in getn()&quot;);
      }

      if (index[0] &lt; this.markerIndex) {
        this.markerIndex = 0;
        return (0xFF00 | this.marker) &lt;&lt; 8;
      }

      result = temp[0] &gt;&gt; index[0];
      temp[0] &amp;= (mask &gt;&gt; (16 - index[0]));
    }

    if (result &lt; (one &lt;&lt; (n - 1))) {
      result += (n_one &lt;&lt; n) + 1;
    }

    return result;
  };



  jpeg.lossless.Decoder.prototype.getPreviousX = function () {
    /*jslint bitwise: true */

    if (this.xLoc &gt; 0) {
      return this.getter((((this.yLoc * this.xDim) + this.xLoc) - 1));
    } else if (this.yLoc &gt; 0) {
      return this.getPreviousY();
    } else {
      return (1 &lt;&lt; (this.frame.precision - 1));
    }
  };



  jpeg.lossless.Decoder.prototype.getPreviousXY = function () {
    /*jslint bitwise: true */

    if ((this.xLoc &gt; 0) &amp;&amp; (this.yLoc &gt; 0)) {
      return this.getter(((((this.yLoc - 1) * this.xDim) + this.xLoc) - 1));
    } else {
      return this.getPreviousY();
    }
  };



  jpeg.lossless.Decoder.prototype.getPreviousY = function () {
    /*jslint bitwise: true */

    if (this.yLoc &gt; 0) {
      return this.getter((((this.yLoc - 1) * this.xDim) + this.xLoc));
    } else {
      return this.getPreviousX();
    }
  };



  jpeg.lossless.Decoder.prototype.isLastPixel = function () {
    return (this.xLoc === (this.xDim - 1)) &amp;&amp; (this.yLoc === (this.yDim - 1));
  };



  jpeg.lossless.Decoder.prototype.output = function (PRED) {
    if ((this.xLoc &lt; this.xDim) &amp;&amp; (this.yLoc &lt; this.yDim)) {
      this.setter((((this.yLoc * this.xDim) + this.xLoc)), PRED[0]);

      this.xLoc+=1;

      if (this.xLoc &gt;= this.xDim) {
        this.yLoc+=1;
        this.xLoc = 0;
      }
    }
  };



  jpeg.lossless.Decoder.prototype.setValue16 = function (index, val) {
    this.outputData.setInt16(index * 2, val, true);
  };



  jpeg.lossless.Decoder.prototype.getValue16 = function (index) {
    return this.outputData.getInt16(index * 2, true);
  };



  jpeg.lossless.Decoder.prototype.setValue8 = function (index, val) {
    this.outputData.setInt8(index, val);
  };



  jpeg.lossless.Decoder.prototype.getValue8 = function (index) {
    return this.outputData.getInt8(index);
  };



  jpeg.lossless.Decoder.prototype.readApp = function() {
    var count = 0, length = this.stream.get16();
    count += 2;

    while (count &lt; length) {
      this.stream.get8();
      count+=1;
    }

    return length;
  };



  jpeg.lossless.Decoder.prototype.readComment = function () {
    var sb = &quot;&quot;, count = 0, length;

    length = this.stream.get16();
    count += 2;

    while (count &lt; length) {
      sb += this.stream.get8();
      count+=1;
    }

    return sb;
  };



  jpeg.lossless.Decoder.prototype.readNumber = function() {
    var Ld = this.stream.get16();

    if (Ld !== 4) {
      throw new Error(&quot;ERROR: Define number format throw new IOException [Ld!=4]&quot;);
    }

    return this.stream.get16();
  };



  jpeg.lossless.Decoder.prototype.scaleIDCT = function (matrix) {
    /*jslint bitwise: true */

    var p = jpeg.lossless.Utils.createArray(8, 8), t0, t1, t2, t3, i, src0, src1, src2, src3, src4, src5, src6, src7, det0, det1, det2, det3, det4,
      det5, det6, det7, mindex = 0;

    for (i = 0; i &lt; 8; i+=1) {
      src0 = this.IDCT_Source[(0) + i];
      src1 = this.IDCT_Source[(8) + i];
      src2 = this.IDCT_Source[(16) + i] - this.IDCT_Source[(24) + i];
      src3 = this.IDCT_Source[(24) + i] + this.IDCT_Source[(16) + i];
      src4 = this.IDCT_Source[(32) + i] - this.IDCT_Source[(56) + i];
      src6 = this.IDCT_Source[(40) + i] - this.IDCT_Source[(48) + i];
      t0 = this.IDCT_Source[(40) + i] + this.IDCT_Source[(48) + i];
      t1 = this.IDCT_Source[(32) + i] + this.IDCT_Source[(56) + i];
      src5 = t0 - t1;
      src7 = t0 + t1;

      det4 = (-src4 * 480) - (src6 * 192);
      det5 = src5 * 384;
      det6 = (src6 * 480) - (src4 * 192);
      det7 = src7 * 256;
      t0 = src0 * 256;
      t1 = src1 * 256;
      t2 = src2 * 384;
      t3 = src3 * 256;
      det3 = t3;
      det0 = t0 + t1;
      det1 = t0 - t1;
      det2 = t2 - t3;

      src0 = det0 + det3;
      src1 = det1 + det2;
      src2 = det1 - det2;
      src3 = det0 - det3;
      src4 = det6 - det4 - det5 - det7;
      src5 = (det5 - det6) + det7;
      src6 = det6 - det7;
      src7 = det7;

      p[0][i] = (src0 + src7 + (1 &lt;&lt; 12)) &gt;&gt; 13;
      p[1][i] = (src1 + src6 + (1 &lt;&lt; 12)) &gt;&gt; 13;
      p[2][i] = (src2 + src5 + (1 &lt;&lt; 12)) &gt;&gt; 13;
      p[3][i] = (src3 + src4 + (1 &lt;&lt; 12)) &gt;&gt; 13;
      p[4][i] = ((src3 - src4) + (1 &lt;&lt; 12)) &gt;&gt; 13;
      p[5][i] = ((src2 - src5) + (1 &lt;&lt; 12)) &gt;&gt; 13;
      p[6][i] = ((src1 - src6) + (1 &lt;&lt; 12)) &gt;&gt; 13;
      p[7][i] = ((src0 - src7) + (1 &lt;&lt; 12)) &gt;&gt; 13;
    }

    for (i = 0; i &lt; 8; i+=1) {
      src0 = p[i][0];
      src1 = p[i][1];
      src2 = p[i][2] - p[i][3];
      src3 = p[i][3] + p[i][2];
      src4 = p[i][4] - p[i][7];
      src6 = p[i][5] - p[i][6];
      t0 = p[i][5] + p[i][6];
      t1 = p[i][4] + p[i][7];
      src5 = t0 - t1;
      src7 = t0 + t1;

      det4 = (-src4 * 480) - (src6 * 192);
      det5 = src5 * 384;
      det6 = (src6 * 480) - (src4 * 192);
      det7 = src7 * 256;
      t0 = src0 * 256;
      t1 = src1 * 256;
      t2 = src2 * 384;
      t3 = src3 * 256;
      det3 = t3;
      det0 = t0 + t1;
      det1 = t0 - t1;
      det2 = t2 - t3;

      src0 = det0 + det3;
      src1 = det1 + det2;
      src2 = det1 - det2;
      src3 = det0 - det3;
      src4 = det6 - det4 - det5 - det7;
      src5 = (det5 - det6) + det7;
      src6 = det6 - det7;
      src7 = det7;

      matrix[mindex+=1] = (src0 + src7 + (1 &lt;&lt; 12)) &gt;&gt; 13;
      matrix[mindex+=1] = (src1 + src6 + (1 &lt;&lt; 12)) &gt;&gt; 13;
      matrix[mindex+=1] = (src2 + src5 + (1 &lt;&lt; 12)) &gt;&gt; 13;
      matrix[mindex+=1] = (src3 + src4 + (1 &lt;&lt; 12)) &gt;&gt; 13;
      matrix[mindex+=1] = ((src3 - src4) + (1 &lt;&lt; 12)) &gt;&gt; 13;
      matrix[mindex+=1] = ((src2 - src5) + (1 &lt;&lt; 12)) &gt;&gt; 13;
      matrix[mindex+=1] = ((src1 - src6) + (1 &lt;&lt; 12)) &gt;&gt; 13;
      matrix[mindex+=1] = ((src0 - src7) + (1 &lt;&lt; 12)) &gt;&gt; 13;
    }
  };



  /*** Exports ***/

  var moduleType = typeof module;
  if ((moduleType !== &apos;undefined&apos;) &amp;&amp; module.exports) {
    module.exports = jpeg.lossless.Decoder;
  }

},{&quot;./data-stream.js&quot;:2,&quot;./frame-header.js&quot;:4,&quot;./huffman-table.js&quot;:5,&quot;./quantization-table.js&quot;:7,&quot;./scan-header.js&quot;:9,&quot;./utils.js&quot;:10}],4:[function(require,module,exports){
  /*
   * Copyright (C) 2015 Michael Martinez
   * Changes: Added support for selection values 2-7, fixed minor bugs &amp;
   * warnings, split into multiple class files, and general clean up.
   *
   * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
   */

  /*
   * Copyright (C) Helmut Dersch
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the &quot;Software&quot;), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:

   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.

   * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /*jslint browser: true, node: true */
  /*global require, module */

  &quot;use strict&quot;;

  /*** Imports ***/
  var jpeg = jpeg || {};
  jpeg.lossless = jpeg.lossless || {};
  jpeg.lossless.ComponentSpec = jpeg.lossless.ComponentSpec || ((typeof require !== &apos;undefined&apos;) ? require(&apos;./component-spec.js&apos;) : null);
  jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== &apos;undefined&apos;) ? require(&apos;./data-stream.js&apos;) : null);


  /*** Constructor ***/
  jpeg.lossless.FrameHeader = jpeg.lossless.FrameHeader || function () {
    this.components = []; // Components
    this.dimX = 0; // Number of samples per line
    this.dimY = 0; // Number of lines
    this.numComp = 0; // Number of component in the frame
    this.precision = 0; // Sample Precision (from the original image)
  };



  /*** Prototype Methods ***/

  jpeg.lossless.FrameHeader.prototype.read = function (data) {
    /*jslint bitwise: true */

    var count = 0, length, i, c, temp;

    length = data.get16();
    count += 2;

    this.precision = data.get8();
    count+=1;

    this.dimY = data.get16();
    count += 2;

    this.dimX = data.get16();
    count += 2;

    this.numComp = data.get8();
    count+=1;
    for (i = 1; i &lt;= this.numComp; i+=1) {
      if (count &gt; length) {
        throw new Error(&quot;ERROR: frame format error&quot;);
      }

      c = data.get8();
      count+=1;

      if (count &gt;= length) {
        throw new Error(&quot;ERROR: frame format error [c&gt;=Lf]&quot;);
      }

      temp = data.get8();
      count+=1;

      if (!this.components[c]) {
        this.components[c] = new jpeg.lossless.ComponentSpec();
      }

      this.components[c].hSamp = temp &gt;&gt; 4;
      this.components[c].vSamp = temp &amp; 0x0F;
      this.components[c].quantTableSel = data.get8();
      count+=1;
    }

    if (count !== length) {
      throw new Error(&quot;ERROR: frame format error [Lf!=count]&quot;);
    }

    return 1;
  };


  /*** Exports ***/

  var moduleType = typeof module;
  if ((moduleType !== &apos;undefined&apos;) &amp;&amp; module.exports) {
    module.exports = jpeg.lossless.FrameHeader;
  }

},{&quot;./component-spec.js&quot;:1,&quot;./data-stream.js&quot;:2}],5:[function(require,module,exports){
  /*
   * Copyright (C) 2015 Michael Martinez
   * Changes: Added support for selection values 2-7, fixed minor bugs &amp;
   * warnings, split into multiple class files, and general clean up.
   *
   * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
   */

  /*
   * Copyright (C) Helmut Dersch
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the &quot;Software&quot;), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:

   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.

   * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /*jslint browser: true, node: true */
  /*global require, module */

  &quot;use strict&quot;;

  /*** Imports ***/
  var jpeg = jpeg || {};
  jpeg.lossless = jpeg.lossless || {};
  jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== &apos;undefined&apos;) ? require(&apos;./data-stream.js&apos;) : null);
  jpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== &apos;undefined&apos;) ? require(&apos;./utils.js&apos;) : null);


  /*** Constructor ***/
  jpeg.lossless.HuffmanTable = jpeg.lossless.HuffmanTable || function () {
    this.l = jpeg.lossless.Utils.createArray(4, 2, 16);
    this.th = [];
    this.v = jpeg.lossless.Utils.createArray(4, 2, 16, 200);
    this.tc = jpeg.lossless.Utils.createArray(4, 2);

    this.tc[0][0] = 0;
    this.tc[1][0] = 0;
    this.tc[2][0] = 0;
    this.tc[3][0] = 0;
    this.tc[0][1] = 0;
    this.tc[1][1] = 0;
    this.tc[2][1] = 0;
    this.tc[3][1] = 0;
    this.th[0] = 0;
    this.th[1] = 0;
    this.th[2] = 0;
    this.th[3] = 0;
  };



  /*** Static Pseudo-constants ***/

  jpeg.lossless.HuffmanTable.MSB = 0x80000000;


  /*** Prototype Methods ***/

  jpeg.lossless.HuffmanTable.prototype.read = function(data, HuffTab) {
    /*jslint bitwise: true */

    var count = 0, length, temp, t, c, i, j;

    length = data.get16();
    count += 2;

    while (count &lt; length) {
      temp = data.get8();
      count+=1;
      t = temp &amp; 0x0F;
      if (t &gt; 3) {
        throw new Error(&quot;ERROR: Huffman table ID &gt; 3&quot;);
      }

      c = temp &gt;&gt; 4;
      if (c &gt; 2) {
        throw new Error(&quot;ERROR: Huffman table [Table class &gt; 2 ]&quot;);
      }

      this.th[t] = 1;
      this.tc[t][c] = 1;

      for (i = 0; i &lt; 16; i+=1) {
        this.l[t][c][i] = data.get8();
        count+=1;
      }

      for (i = 0; i &lt; 16; i+=1) {
        for (j = 0; j &lt; this.l[t][c][i]; j+=1) {
          if (count &gt; length) {
            throw new Error(&quot;ERROR: Huffman table format error [count&gt;Lh]&quot;);
          }

          this.v[t][c][i][j] = data.get8();
          count+=1;
        }
      }
    }

    if (count !== length) {
      throw new Error(&quot;ERROR: Huffman table format error [count!=Lf]&quot;);
    }

    for (i = 0; i &lt; 4; i+=1) {
      for (j = 0; j &lt; 2; j+=1) {
        if (this.tc[i][j] !== 0) {
          this.buildHuffTable(HuffTab[i][j], this.l[i][j], this.v[i][j]);
        }
      }
    }

    return 1;
  };



//	Build_HuffTab()
//	Parameter:  t       table ID
//	            c       table class ( 0 for DC, 1 for AC )
//	            L[i]    # of codewords which length is i
//	            V[i][j] Huffman Value (length=i)
//	Effect:
//	    build up HuffTab[t][c] using L and V.
  jpeg.lossless.HuffmanTable.prototype.buildHuffTable = function(tab, L, V) {
    /*jslint bitwise: true */

    var currentTable, temp, k, i, j, n;
    temp = 256;
    k = 0;

    for (i = 0; i &lt; 8; i+=1) { // i+1 is Code length
      for (j = 0; j &lt; L[i]; j+=1) {
        for (n = 0; n &lt; (temp &gt;&gt; (i + 1)); n+=1) {
          tab[k] = V[i][j] | ((i + 1) &lt;&lt; 8);
          k+=1;
        }
      }
    }

    for (i = 1; k &lt; 256; i+=1, k+=1) {
      tab[k] = i | jpeg.lossless.HuffmanTable.MSB;
    }

    currentTable = 1;
    k = 0;

    for (i = 8; i &lt; 16; i+=1) { // i+1 is Code length
      for (j = 0; j &lt; L[i]; j+=1) {
        for (n = 0; n &lt; (temp &gt;&gt; (i - 7)); n+=1) {
          tab[(currentTable * 256) + k] = V[i][j] | ((i + 1) &lt;&lt; 8);
          k+=1;
        }

        if (k &gt;= 256) {
          if (k &gt; 256) {
            throw new Error(&quot;ERROR: Huffman table error(1)!&quot;);
          }

          k = 0;
          currentTable+=1;
        }
      }
    }
  };


  /*** Exports ***/

  var moduleType = typeof module;
  if ((moduleType !== &apos;undefined&apos;) &amp;&amp; module.exports) {
    module.exports = jpeg.lossless.HuffmanTable;
  }

},{&quot;./data-stream.js&quot;:2,&quot;./utils.js&quot;:10}],6:[function(require,module,exports){
  /*jslint browser: true, node: true */
  /*global require, module */

  &quot;use strict&quot;;

  /*** Imports ***/
  var jpeg = jpeg || {};
  jpeg.lossless = jpeg.lossless || {};
  jpeg.lossless.ComponentSpec = jpeg.lossless.ComponentSpec || ((typeof require !== &apos;undefined&apos;) ? require(&apos;./component-spec.js&apos;) : null);
  jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== &apos;undefined&apos;) ? require(&apos;./data-stream.js&apos;) : null);
  jpeg.lossless.Decoder = jpeg.lossless.Decoder || ((typeof require !== &apos;undefined&apos;) ? require(&apos;./decoder.js&apos;) : null);
  jpeg.lossless.FrameHeader = jpeg.lossless.FrameHeader || ((typeof require !== &apos;undefined&apos;) ? require(&apos;./frame-header.js&apos;) : null);
  jpeg.lossless.HuffmanTable = jpeg.lossless.HuffmanTable || ((typeof require !== &apos;undefined&apos;) ? require(&apos;./huffman-table.js&apos;) : null);
  jpeg.lossless.QuantizationTable = jpeg.lossless.QuantizationTable || ((typeof require !== &apos;undefined&apos;) ? require(&apos;./quantization-table.js&apos;) : null);
  jpeg.lossless.ScanComponent = jpeg.lossless.ScanComponent || ((typeof require !== &apos;undefined&apos;) ? require(&apos;./scan-component.js&apos;) : null);
  jpeg.lossless.ScanHeader = jpeg.lossless.ScanHeader || ((typeof require !== &apos;undefined&apos;) ? require(&apos;./scan-header.js&apos;) : null);
  jpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== &apos;undefined&apos;) ? require(&apos;./utils.js&apos;) : null);


  /*** Exports ***/
  var moduleType = typeof module;
  if ((moduleType !== &apos;undefined&apos;) &amp;&amp; module.exports) {
    module.exports = jpeg;
  }

},{&quot;./component-spec.js&quot;:1,&quot;./data-stream.js&quot;:2,&quot;./decoder.js&quot;:3,&quot;./frame-header.js&quot;:4,&quot;./huffman-table.js&quot;:5,&quot;./quantization-table.js&quot;:7,&quot;./scan-component.js&quot;:8,&quot;./scan-header.js&quot;:9,&quot;./utils.js&quot;:10}],7:[function(require,module,exports){
  /*
   * Copyright (C) 2015 Michael Martinez
   * Changes: Added support for selection values 2-7, fixed minor bugs &amp;
   * warnings, split into multiple class files, and general clean up.
   *
   * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
   */

  /*
   * Copyright (C) Helmut Dersch
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the &quot;Software&quot;), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:

   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.

   * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /*jslint browser: true, node: true */
  /*global require, module */

  &quot;use strict&quot;;

  /*** Imports ***/
  var jpeg = jpeg || {};
  jpeg.lossless = jpeg.lossless || {};
  jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== &apos;undefined&apos;) ? require(&apos;./data-stream.js&apos;) : null);
  jpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== &apos;undefined&apos;) ? require(&apos;./utils.js&apos;) : null);


  /*** Constructor ***/
  jpeg.lossless.QuantizationTable = jpeg.lossless.QuantizationTable || function () {
    this.precision = []; // Quantization precision 8 or 16
    this.tq = []; // 1: this table is presented
    this.quantTables = jpeg.lossless.Utils.createArray(4, 64); // Tables

    this.tq[0] = 0;
    this.tq[1] = 0;
    this.tq[2] = 0;
    this.tq[3] = 0;
  };



  /*** Static Methods ***/

  jpeg.lossless.QuantizationTable.enhanceQuantizationTable = function(qtab, table) {
    /*jslint bitwise: true */

    var i;

    for (i = 0; i &lt; 8; i+=1) {
      qtab[table[(0 * 8) + i]] *= 90;
      qtab[table[(4 * 8) + i]] *= 90;
      qtab[table[(2 * 8) + i]] *= 118;
      qtab[table[(6 * 8) + i]] *= 49;
      qtab[table[(5 * 8) + i]] *= 71;
      qtab[table[(1 * 8) + i]] *= 126;
      qtab[table[(7 * 8) + i]] *= 25;
      qtab[table[(3 * 8) + i]] *= 106;
    }

    for (i = 0; i &lt; 8; i+=1) {
      qtab[table[0 + (8 * i)]] *= 90;
      qtab[table[4 + (8 * i)]] *= 90;
      qtab[table[2 + (8 * i)]] *= 118;
      qtab[table[6 + (8 * i)]] *= 49;
      qtab[table[5 + (8 * i)]] *= 71;
      qtab[table[1 + (8 * i)]] *= 126;
      qtab[table[7 + (8 * i)]] *= 25;
      qtab[table[3 + (8 * i)]] *= 106;
    }

    for (i = 0; i &lt; 64; i+=1) {
      qtab[i] &gt;&gt;= 6;
    }
  };


  /*** Prototype Methods ***/

  jpeg.lossless.QuantizationTable.prototype.read = function (data, table) {
    /*jslint bitwise: true */

    var count = 0, length, temp, t, i;

    length = data.get16();
    count += 2;

    while (count &lt; length) {
      temp = data.get8();
      count+=1;
      t = temp &amp; 0x0F;

      if (t &gt; 3) {
        throw new Error(&quot;ERROR: Quantization table ID &gt; 3&quot;);
      }

      this.precision[t] = temp &gt;&gt; 4;

      if (this.precision[t] === 0) {
        this.precision[t] = 8;
      } else if (this.precision[t] === 1) {
        this.precision[t] = 16;
      } else {
        throw new Error(&quot;ERROR: Quantization table precision error&quot;);
      }

      this.tq[t] = 1;

      if (this.precision[t] === 8) {
        for (i = 0; i &lt; 64; i+=1) {
          if (count &gt; length) {
            throw new Error(&quot;ERROR: Quantization table format error&quot;);
          }

          this.quantTables[t][i] = data.get8();
          count+=1;
        }

        jpeg.lossless.QuantizationTable.enhanceQuantizationTable(this.quantTables[t], table);
      } else {
        for (i = 0; i &lt; 64; i+=1) {
          if (count &gt; length) {
            throw new Error(&quot;ERROR: Quantization table format error&quot;);
          }

          this.quantTables[t][i] = data.get16();
          count += 2;
        }

        jpeg.lossless.QuantizationTable.enhanceQuantizationTable(this.quantTables[t], table);
      }
    }

    if (count !== length) {
      throw new Error(&quot;ERROR: Quantization table error [count!=Lq]&quot;);
    }

    return 1;
  };



  /*** Exports ***/

  var moduleType = typeof module;
  if ((moduleType !== &apos;undefined&apos;) &amp;&amp; module.exports) {
    module.exports = jpeg.lossless.QuantizationTable;
  }

},{&quot;./data-stream.js&quot;:2,&quot;./utils.js&quot;:10}],8:[function(require,module,exports){
  /*
   * Copyright (C) 2015 Michael Martinez
   * Changes: Added support for selection values 2-7, fixed minor bugs &amp;
   * warnings, split into multiple class files, and general clean up.
   *
   * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
   */

  /*
   * Copyright (C) Helmut Dersch
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the &quot;Software&quot;), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:

   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.

   * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /*jslint browser: true, node: true */
  /*global require, module */

  &quot;use strict&quot;;

  /*** Imports ***/
  var jpeg = jpeg || {};
  jpeg.lossless = jpeg.lossless || {};


  /*** Constructor ***/
  jpeg.lossless.ScanComponent = jpeg.lossless.ScanComponent || function () {
    this.acTabSel = 0; // AC table selector
    this.dcTabSel = 0; // DC table selector
    this.scanCompSel = 0; // Scan component selector
  };



  /*** Exports ***/

  var moduleType = typeof module;
  if ((moduleType !== &apos;undefined&apos;) &amp;&amp; module.exports) {
    module.exports = jpeg.lossless.ScanComponent;
  }

},{}],9:[function(require,module,exports){
  /*
   * Copyright (C) 2015 Michael Martinez
   * Changes: Added support for selection values 2-7, fixed minor bugs &amp;
   * warnings, split into multiple class files, and general clean up.
   *
   * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
   */

  /*
   * Copyright (C) Helmut Dersch
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the &quot;Software&quot;), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:

   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.

   * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /*jslint browser: true, node: true */
  /*global require, module */

  &quot;use strict&quot;;

  /*** Imports ***/
  var jpeg = jpeg || {};
  jpeg.lossless = jpeg.lossless || {};
  jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== &apos;undefined&apos;) ? require(&apos;./data-stream.js&apos;) : null);
  jpeg.lossless.ScanComponent = jpeg.lossless.ScanComponent || ((typeof require !== &apos;undefined&apos;) ? require(&apos;./scan-component.js&apos;) : null);


  /*** Constructor ***/
  jpeg.lossless.ScanHeader = jpeg.lossless.ScanHeader || function () {
    this.ah = 0;
    this.al = 0;
    this.numComp = 0; // Number of components in the scan
    this.selection = 0; // Start of spectral or predictor selection
    this.spectralEnd = 0; // End of spectral selection
    this.components = [];
  };


  /*** Prototype Methods ***/

  jpeg.lossless.ScanHeader.prototype.read = function(data) {
    /*jslint bitwise: true */

    var count = 0, length, i, temp;

    length = data.get16();
    count += 2;

    this.numComp = data.get8();
    count+=1;

    for (i = 0; i &lt; this.numComp; i+=1) {
      this.components[i] = new jpeg.lossless.ScanComponent();

      if (count &gt; length) {
        throw new Error(&quot;ERROR: scan header format error&quot;);
      }

      this.components[i].scanCompSel = data.get8();
      count+=1;

      temp = data.get8();
      count+=1;

      this.components[i].dcTabSel = (temp &gt;&gt; 4);
      this.components[i].acTabSel = (temp &amp; 0x0F);
    }

    this.selection = data.get8();
    count+=1;

    this.spectralEnd = data.get8();
    count+=1;

    temp = data.get8();
    this.ah = (temp &gt;&gt; 4);
    this.al = (temp &amp; 0x0F);
    count+=1;

    if (count !== length) {
      throw new Error(&quot;ERROR: scan header format error [count!=Ns]&quot;);
    }

    return 1;
  };



  /*** Exports ***/

  var moduleType = typeof module;
  if ((moduleType !== &apos;undefined&apos;) &amp;&amp; module.exports) {
    module.exports = jpeg.lossless.ScanHeader;
  }

},{&quot;./data-stream.js&quot;:2,&quot;./scan-component.js&quot;:8}],10:[function(require,module,exports){
  /*
   * Copyright (C) 2015 Michael Martinez
   * Changes: Added support for selection values 2-7, fixed minor bugs &amp;
   * warnings, split into multiple class files, and general clean up.
   *
   * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
   */

  /*
   * Copyright (C) Helmut Dersch
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the &quot;Software&quot;), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:

   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.

   * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /*jslint browser: true, node: true */
  /*global require, module */

  &quot;use strict&quot;;

  /*** Imports ***/
  var jpeg = jpeg || {};
  jpeg.lossless = jpeg.lossless || {};


  /*** Constructor ***/
  jpeg.lossless.Utils = jpeg.lossless.Utils || {};


  /*** Static methods ***/

// http://stackoverflow.com/questions/966225/how-can-i-create-a-two-dimensional-array-in-javascript
  jpeg.lossless.Utils.createArray = function (length) {
    var arr = new Array(length || 0),
      i = length;

    if (arguments.length &gt; 1) {
      var args = Array.prototype.slice.call(arguments, 1);
      while(i--) arr[length-1 - i] = jpeg.lossless.Utils.createArray.apply(this, args);
    }

    return arr;
  };


  /*** Exports ***/

  var moduleType = typeof module;
  if ((moduleType !== &apos;undefined&apos;) &amp;&amp; module.exports) {
    module.exports = jpeg.lossless.Utils;
  }

},{}]},{},[6])(6)
});
(function ($, cornerstone, cornerstoneWADOImageLoader) {

  &quot;use strict&quot;;
  function extractUncompressedPixels(dataSet, frame)
  {
    var pixelFormat = cornerstoneWADOImageLoader.getPixelFormat(dataSet);
    var pixelDataElement = dataSet.elements.x7fe00010;
    var height = dataSet.uint16(&apos;x00280010&apos;);
    var width = dataSet.uint16(&apos;x00280011&apos;);
    var samplesPerPixel = dataSet.uint16(&apos;x00280002&apos;);
    var pixelDataOffset = pixelDataElement.dataOffset;
    var numPixels = width * height * samplesPerPixel;
    // Note - we may want to sanity check the rows * columns * bitsAllocated * samplesPerPixel against the buffer size

    var frameOffset = 0;
    if(pixelFormat === 1) {
      frameOffset = pixelDataOffset + frame * numPixels;
      return new Uint8Array(dataSet.byteArray.buffer, frameOffset, numPixels);
    }
    else if(pixelFormat === 2) {
      frameOffset = pixelDataOffset + frame * numPixels * 2;
      return new Uint16Array(dataSet.byteArray.buffer, frameOffset, numPixels);
    }
    else if(pixelFormat === 3) {
      frameOffset = pixelDataOffset + frame * numPixels * 2;
      return new Int16Array(dataSet.byteArray.buffer, frameOffset, numPixels);
    }
  }

  cornerstoneWADOImageLoader.extractUncompressedPixels = extractUncompressedPixels;
}($, cornerstone, cornerstoneWADOImageLoader));
(function (cornerstoneWADOImageLoader) {

  &quot;use strict&quot;;

  function getPixelFormat(dataSet) {
    var pixelRepresentation = dataSet.uint16(&apos;x00280103&apos;);
    var bitsAllocated = dataSet.uint16(&apos;x00280100&apos;);
    if(pixelRepresentation === 0 &amp;&amp; bitsAllocated === 8) {
      return 1; // unsigned 8 bit
    } else if(pixelRepresentation === 0 &amp;&amp; bitsAllocated === 16) {
      return 2; // unsigned 16 bit
    } else if(pixelRepresentation === 1 &amp;&amp; bitsAllocated === 16) {
      return 3; // signed 16 bit data
    }
  }


  // module exports
  cornerstoneWADOImageLoader.getPixelFormat = getPixelFormat;

}(cornerstoneWADOImageLoader));
(function (cornerstoneWADOImageLoader) {

    &quot;use strict&quot;;

    function getPixelSpacing(dataSet)
    {
        // NOTE - these are not required for all SOP Classes
        // so we return them as undefined.  We also do not
        // deal with the complexity associated with projection
        // radiographs here and leave that to a higher layer
        var pixelSpacing = dataSet.string(&apos;x00280030&apos;);
        if(pixelSpacing &amp;&amp; pixelSpacing.length &gt; 0) {
            var split = pixelSpacing.split(&apos;\\&apos;);
            return {
                row: parseFloat(split[0]),
                column: parseFloat(split[1])
            };
        }
        else {
            return {
                row: undefined,
                column: undefined
            };
        }
    }
    // module exports
    cornerstoneWADOImageLoader.getPixelSpacing = getPixelSpacing;
}(cornerstoneWADOImageLoader));
(function (cornerstoneWADOImageLoader) {

    &quot;use strict&quot;;

    function getRescaleSlopeAndIntercept(dataSet)
    {
        // NOTE - we default these to an identity transform since modality LUT
        // module is not required for all SOP Classes
        var result = {
            intercept : 0.0,
            slope: 1.0
        };

        var rescaleIntercept = dataSet.floatString(&apos;x00281052&apos;);
        var rescaleSlope = dataSet.floatString(&apos;x00281053&apos;);

        if(rescaleIntercept &amp;&amp; rescaleSlope) {
            result.intercept = rescaleIntercept;
            result.slope = rescaleSlope;
        }
        return result;
    }

    // module exports
    cornerstoneWADOImageLoader.getRescaleSlopeAndIntercept = getRescaleSlopeAndIntercept;
}(cornerstoneWADOImageLoader));
(function (cornerstoneWADOImageLoader) {

    &quot;use strict&quot;;

    function getWindowWidthAndCenter(dataSet)
    {
        // NOTE - Default these to undefined since they may not be present as
        // they are not present or required for all sop classes.  We leave it up
        // to a higher layer to determine reasonable default values for these
        // if they are not provided.  We also use the first ww/wc values if
        // there are multiple and again leave it up the higher levels to deal with
        // this
        var result = {
            windowCenter : undefined,
            windowWidth: undefined
        };

        var windowCenter = dataSet.floatString(&apos;x00281050&apos;);
        var windowWidth = dataSet.floatString(&apos;x00281051&apos;);

        if(windowCenter &amp;&amp; windowWidth) {
          result.windowCenter = windowCenter;
          result.windowWidth = windowWidth;
        }
        return result;
    }

    // module exports
    cornerstoneWADOImageLoader.getWindowWidthAndCenter = getWindowWidthAndCenter;
}(cornerstoneWADOImageLoader));
(function (cornerstoneWADOImageLoader) {

  &quot;use strict&quot;;

  var options = {
    // callback allowing customization of the xhr (e.g. adding custom auth headers, cors, etc)
    beforeSend : function(xhr) {}
  };

  function configure(opts) {
    options = opts;
  }

  function isColorImage(photoMetricInterpretation)
  {
    if(photoMetricInterpretation === &quot;RGB&quot; ||
      photoMetricInterpretation === &quot;PALETTE COLOR&quot; ||
      photoMetricInterpretation === &quot;YBR_FULL&quot; ||
      photoMetricInterpretation === &quot;YBR_FULL_422&quot; ||
      photoMetricInterpretation === &quot;YBR_PARTIAL_422&quot; ||
      photoMetricInterpretation === &quot;YBR_PARTIAL_420&quot; ||
      photoMetricInterpretation === &quot;YBR_RCT&quot; ||
      photoMetricInterpretation === &quot;YBR_ICT&quot;)
    {
      return true;
    }
    else
    {
      return false;
    }
  }

  cornerstoneWADOImageLoader.isColorImage = isColorImage;

}(cornerstoneWADOImageLoader));
(function ($, cornerstone, cornerstoneWADOImageLoader) {

    &quot;use strict&quot;;

    var canvas = document.createElement(&apos;canvas&apos;);
    var lastImageIdDrawn = &quot;&quot;;

    function extractStoredPixels(dataSet, frame) {

        // special case for JPEG Baseline 8 bit
        if(cornerstoneWADOImageLoader.isJPEGBaseline8Bit(dataSet) === true)
        {
          return cornerstoneWADOImageLoader.decodeJPEGBaseline8Bit(canvas, dataSet, frame);
        }

        var decodedImageFrame = cornerstoneWADOImageLoader.decodeTransferSyntax(dataSet, frame);

        return cornerstoneWADOImageLoader.convertColorSpace(canvas, dataSet, decodedImageFrame);
    }

    function makeColorImage(imageId, dataSet, frame) {

        // extract the DICOM attributes we need
        var pixelSpacing = cornerstoneWADOImageLoader.getPixelSpacing(dataSet);
        var rows = dataSet.uint16(&apos;x00280010&apos;);
        var columns = dataSet.uint16(&apos;x00280011&apos;);
        var rescaleSlopeAndIntercept = cornerstoneWADOImageLoader.getRescaleSlopeAndIntercept(dataSet);
        var bytesPerPixel = 4;
        var numPixels = rows * columns;
        var sizeInBytes = numPixels * bytesPerPixel;
        var windowWidthAndCenter = cornerstoneWADOImageLoader.getWindowWidthAndCenter(dataSet);

        // clear the lastImageIdDrawn so we update the canvas
        lastImageIdDrawn = undefined;

        var deferred = $.Deferred();

        // Decompress and decode the pixel data for this image
        var imageDataPromise;
        try {
          imageDataPromise = extractStoredPixels(dataSet, frame);
        }
        catch(err) {
          deferred.reject(err);
          return deferred;
        }

        imageDataPromise.then(function(imageData) {
            function getPixelData() {
                return imageData.data;
            }

            function getImageData() {
                return imageData;
            }

            function getCanvas() {
                if(lastImageIdDrawn === imageId) {
                    return canvas;
                }

                canvas.height = rows;
                canvas.width = columns;
                var context = canvas.getContext(&apos;2d&apos;);
                context.putImageData(imageData, 0, 0 );
                lastImageIdDrawn = imageId;
                return canvas;
            }

            // Extract the various attributes we need
            var image = {
                imageId : imageId,
                minPixelValue : 0,
                maxPixelValue : 255,
                slope: rescaleSlopeAndIntercept.slope,
                intercept: rescaleSlopeAndIntercept.intercept,
                windowCenter : windowWidthAndCenter.windowCenter,
                windowWidth : windowWidthAndCenter.windowWidth,
                render: cornerstone.renderColorImage,
                getPixelData: getPixelData,
                getImageData: getImageData,
                getCanvas: getCanvas,
                rows: rows,
                columns: columns,
                height: rows,
                width: columns,
                color: true,
                columnPixelSpacing: pixelSpacing.column,
                rowPixelSpacing: pixelSpacing.row,
                data: dataSet,
                invert: false,
                sizeInBytes: sizeInBytes
            };

            if(image.windowCenter === undefined) {
                image.windowWidth = 255;
                image.windowCenter = 128;
            }
            deferred.resolve(image);
        }, function(error) {
            deferred.reject(error);
        });

        return deferred;
    }

    // module exports
    cornerstoneWADOImageLoader.makeColorImage = makeColorImage;
}($, cornerstone, cornerstoneWADOImageLoader));
(function ($, cornerstone, cornerstoneWADOImageLoader) {

    &quot;use strict&quot;;

    function getBytesPerPixel(dataSet)
    {
        var pixelFormat = cornerstoneWADOImageLoader.getPixelFormat(dataSet);
        if(pixelFormat ===1) {
            return 1;
        }
        else if(pixelFormat ===2 || pixelFormat ===3){
            return 2;
        }
        throw &quot;unknown pixel format&quot;;
    }

    function getMinMax(storedPixelData)
    {
        // we always calculate the min max values since they are not always
        // present in DICOM and we don&apos;t want to trust them anyway as cornerstone
        // depends on us providing reliable values for these
        var min = 65535;
        var max = -32768;
        var numPixels = storedPixelData.length;
        var pixelData = storedPixelData;
        for(var index = 0; index &lt; numPixels; index++) {
            var spv = pixelData[index];
            // TODO: test to see if it is faster to use conditional here rather than calling min/max functions
            min = Math.min(min, spv);
            max = Math.max(max, spv);
        }

        return {
            min: min,
            max: max
        };
    }

    function makeGrayscaleImage(imageId, dataSet, frame) {
        var deferred = $.Deferred();

        // extract the DICOM attributes we need
        var pixelSpacing = cornerstoneWADOImageLoader.getPixelSpacing(dataSet);
        var rows = dataSet.uint16(&apos;x00280010&apos;);
        var columns = dataSet.uint16(&apos;x00280011&apos;);
        var rescaleSlopeAndIntercept = cornerstoneWADOImageLoader.getRescaleSlopeAndIntercept(dataSet);
        
        var bytesPerPixel;
        try {
            bytesPerPixel = getBytesPerPixel(dataSet);
        } catch(error) {
            deferred.reject(error);
            return deferred;
        }

        var numPixels = rows * columns;
        var sizeInBytes = numPixels * bytesPerPixel;
        var photometricInterpretation = dataSet.string(&apos;x00280004&apos;);
        var invert = (photometricInterpretation === &quot;MONOCHROME1&quot;);
        var windowWidthAndCenter = cornerstoneWADOImageLoader.getWindowWidthAndCenter(dataSet);

        // Decompress and decode the pixel data for this image
        var storedPixelData;
        try {
          storedPixelData = cornerstoneWADOImageLoader.decodeTransferSyntax(dataSet, frame);
        }
        catch(err) {
          deferred.reject(err);
          return deferred;
        }

        var minMax = getMinMax(storedPixelData);

        function getPixelData() {
            return storedPixelData;
        }

        // Extract the various attributes we need
        var image = {
            imageId : imageId,
            minPixelValue : minMax.min,
            maxPixelValue : minMax.max,
            slope: rescaleSlopeAndIntercept.slope,
            intercept: rescaleSlopeAndIntercept.intercept,
            windowCenter : windowWidthAndCenter.windowCenter,
            windowWidth : windowWidthAndCenter.windowWidth,
            render: cornerstone.renderGrayscaleImage,
            getPixelData: getPixelData,
            rows: rows,
            columns: columns,
            height: rows,
            width: columns,
            color: false,
            columnPixelSpacing: pixelSpacing.column,
            rowPixelSpacing: pixelSpacing.row,
            data: dataSet,
            invert: invert,
            sizeInBytes: sizeInBytes
        };

        // TODO: deal with pixel padding and all of the various issues by setting it to min pixel value (or lower)
        // TODO: Mask out overlays embedded in pixel data above high bit

        if(image.windowCenter === undefined) {
            var maxVoi = image.maxPixelValue * image.slope + image.intercept;
            var minVoi = image.minPixelValue * image.slope + image.intercept;
            image.windowWidth = maxVoi - minVoi;
            image.windowCenter = (maxVoi + minVoi) / 2;
        }

        deferred.resolve(image);
        return deferred;
    }

    // module exports
    cornerstoneWADOImageLoader.makeGrayscaleImage = makeGrayscaleImage;
}($, cornerstone, cornerstoneWADOImageLoader));
(function (cornerstoneWADOImageLoader) {

  &quot;use strict&quot;;

  // module exports
  cornerstoneWADOImageLoader.version = &apos;0.7.0&apos;;

}(cornerstoneWADOImageLoader));
(function ($, cornerstone, cornerstoneWADOImageLoader) {

  &quot;use strict&quot;;

  function xhrRequest(imageId, frame, url) {

    var deferred = $.Deferred();

    // Make the request for the DICOM P10 SOP Instance
    var xhr = new XMLHttpRequest();
    xhr.responseType = &quot;arraybuffer&quot;;
    xhr.open(&quot;get&quot;, url, true);
    cornerstoneWADOImageLoader.internal.options.beforeSend(xhr);
    xhr.onreadystatechange = function (oEvent) {
      // TODO: consider sending out progress messages here as we receive the pixel data
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          // request succeeded, create an image object and resolve the deferred

          // Parse the DICOM File
          var dicomPart10AsArrayBuffer = xhr.response;
          var byteArray = new Uint8Array(dicomPart10AsArrayBuffer);
          var dataSet = dicomParser.parseDicom(byteArray);

          // if multiframe, cache the parsed data set to speed up subsequent
          // requests for the other frames
          if (frame !== undefined) {
            cornerstoneWADOImageLoader.internal.multiFrameCacheHack[url] = dataSet;
          }

          var imagePromise = cornerstoneWADOImageLoader.createImageObject(dataSet, imageId, frame);
          imagePromise.then(function (image) {
            deferred.resolve(image);
          }, function (error) {
            deferred.reject(error);
          });
        }
        else {
          // request failed, reject the deferred
          deferred.reject(xhr.response);
        }
      }
    };
    xhr.onprogress = function (oProgress) {
      // console.log(&apos;progress:&apos;,oProgress)

      if (oProgress.lengthComputable) {  //evt.loaded the bytes browser receive
        //evt.total the total bytes seted by the header
        //
        var loaded = oProgress.loaded;
        var total = oProgress.total;
        var percentComplete = Math.round((loaded / total) * 100);

        $(cornerstone).trigger(&apos;CornerstoneImageLoadProgress&apos;, {
          imageId: imageId,
          loaded: loaded,
          total: total,
          percentComplete: percentComplete
        });
      }
    };

    xhr.send();

    return deferred;
  }

  cornerstoneWADOImageLoader.internal.xhrRequest = xhrRequest;
}($, cornerstone, cornerstoneWADOImageLoader));</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
